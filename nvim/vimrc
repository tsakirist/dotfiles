" ----------------------------------------- vim: set sw=2: -----------------------------------------
"
"                                 ██╗   ██╗██╗███╗   ███╗██████╗  ██████╗
"                                 ██║   ██║██║████╗ ████║██╔══██╗██╔════╝
"                                 ██║   ██║██║██╔████╔██║██████╔╝██║
"                                 ╚██╗ ██╔╝██║██║╚██╔╝██║██╔══██╗██║
"                                  ╚████╔╝ ██║██║ ╚═╝ ██║██║  ██║╚██████╗
"                                   ╚═══╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝
" Author: Tryfon Tsakiris
"  Email: tr.tsakiris@gmail.com
"    URL: https://raw.githubusercontent.com/tsakirist/dotfiles/master/nvim/vimrc
" --------------------------------------------------------------------------------------------------

" ----------------------------------- 1. Compatible {{{

" Vim defaults to `compatible` when selecting a vimrc with the command-line '-u' argument.
" Override that behaviour to nocompatible.
if &compatible
  set nocompatible
endif

" }}}

" ----------------------------------- 2. Plugins {{{

" ----------------------------------- 1. Plugin installer {{{

" Automate the process of installing vim-plug when required
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Install missing plugins during startup
autocmd VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  \| PlugInstall --sync | q | source $MYVIMRC
\| endif

" }}}

" ----------------------------------- 2. Plugin list {{{

" Plugins will be downloaded under the specified directory
call plug#begin('~/.vim/plugged')

" Colorschemes
" Plug 'joshdick/onedark.vim'
Plug 'ful1e5/onedark.nvim'
Plug 'doums/darcula'
Plug 'EdenEast/nightfox.nvim'

" Lua-based statusline
Plug 'hoob3rt/lualine.nvim'

" Simple tabline for opened buffers
Plug 'pacha/vem-tabline'

" Add file type icons to various plugins
Plug 'kyazdani42/nvim-web-devicons'

" Fancy starting screen
Plug 'mhinz/vim-startify'

" Distraction free mode
Plug 'junegunn/goyo.vim', { 'on': 'Goyo' }

" Display available keybinds in pop-up
Plug 'liuchengxu/vim-which-key'

" Measure the startup time of vim
Plug 'dstein64/vim-startuptime', { 'on': 'StartupTime' }

" An interactive calculator inside a buffer
Plug 'fedorenchik/VimCalc3', { 'on': 'Calc' }

" Some useful keymappings
Plug 'tpope/vim-unimpaired'

" Supecharged substitute command and more
Plug 'tpope/vim-abolish', { 'on': 'Subvert' }

" Smart and powerful comment plugin
Plug 'numToStr/Comment.nvim'

" Display indentation levels with lines
Plug 'lukas-reineke/indent-blankline.nvim'

" Surround mappings for enclosed text
Plug 'tpope/vim-surround'

" Auto insert brackets, parentheses, etc
Plug 'windwp/nvim-autopairs'
Plug 'windwp/nvim-ts-autotag'

" Alternate between absolute/relative numbers
Plug 'jeffkreeftmeijer/vim-numbertoggle'

" Text alignment
Plug 'junegunn/vim-easy-align', { 'on': ['<Plug>(EasyAlign)', '<Plug>(LiveEasyAlign)'] }

" Rooter changes the working directory to the project root when you open a file or directory
Plug 'airblade/vim-rooter'

" Remove all buffers except current
Plug 'numtostr/BufOnly.nvim', { 'on': 'BufOnly' }

" Easy resize windows/splits
Plug 'sedm0784/vim-resize-mode'

" Vim wrapper for UNIX shell commands
Plug 'tpope/vim-eunuch'

" Write/Read files with sudo from within vim
Plug 'lambdalisue/suda.vim'

" Use terminal in a floating pop up window
Plug 'voldikss/vim-floaterm', { 'on': ['FloatermToggle', 'FloatermKill'] }

" Color highlighter
Plug 'norcalli/nvim-colorizer.lua'

" Highlight/Underline word under cursor
Plug 'dominikduda/vim_current_word'

" Easily locate cursor after search
Plug 'inside/vim-search-pulse'

" Visual indication when jumping long distances
Plug 'edluffy/specs.nvim'

" Highlight first occurences of characters in words, e.g. to move with f{char}
Plug 'unblevable/quick-scope'

" Provides git integration for buffers
Plug 'lewis6991/gitsigns.nvim'

" A git wrapper for vim
Plug 'tpope/vim-fugitive'

" A visual git commit browser
Plug 'junegunn/gv.vim', { 'on': ['GV', 'GV!'] }

" Enables :GBrowse to open GitHub urls from vim
Plug 'tpope/vim-rhubarb'

" More pleasant commit experience
Plug 'rhysd/committia.vim'

" Git floating popup with blame-commit details
Plug 'rhysd/git-messenger.vim', { 'on': '<Plug>(git-messenger)' }

" Git blamer with inline text
Plug 'APZelos/blamer.nvim', { 'on': 'BlamerToggle' }

" Switch between single-line and multiline forms of code
Plug 'AndrewRadev/splitjoin.vim'

" Peak lines easiliy with :<number>
Plug 'nacro90/numb.nvim'

" File explorer tree for neovim
Plug 'kyazdani42/nvim-tree.lua'

" Treesitter parser generator tool and incremental parsing library
Plug 'nvim-treesitter/nvim-treesitter', { 'do': ':TSUpdate' }
Plug 'nvim-treesitter/nvim-treesitter-textobjects'
Plug 'nvim-treesitter/playground'

" Treesitter plugin for setting the commentstring based on the cursor location in a file
Plug 'JoosepAlviste/nvim-ts-context-commentstring'

" Telescope fuzzy finder
Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'nvim-telescope/telescope-fzf-native.nvim', { 'do': 'make' }

" Fuzzy finder FZF, this will also install FZF outside of vim plug directory, globally
Plug 'junegunn/fzf', { 'dir': '~/.fzf','do': './install --key-bindings --completion --no-update-rc' }
Plug 'junegunn/fzf.vim'

" Snippet engine in lua
Plug 'L3MON4D3/LuaSnip'

" My Fork with preconfigured snippets for many languages
Plug 'tsakirist/friendly-snippets'

" LSP related
Plug 'neovim/nvim-lspconfig'
Plug 'williamboman/nvim-lsp-installer'
Plug 'ray-x/lsp_signature.nvim'
Plug 'kosayoda/nvim-lightbulb'
Plug 'weilbith/nvim-code-action-menu', { 'on': 'CodeActionMenu' }

" Use Neovim as a language server to inject LSP diagnostics, code actions, formatting and more
Plug 'jose-elias-alvarez/null-ls.nvim'

" Autocomplete
Plug 'hrsh7th/nvim-cmp'
Plug 'hrsh7th/cmp-nvim-lsp'
Plug 'hrsh7th/cmp-nvim-lua'
Plug 'hrsh7th/cmp-buffer'
Plug 'hrsh7th/cmp-path'
Plug 'saadparwaiz1/cmp_luasnip'

" Goto preview in a floating window
Plug 'rmagatti/goto-preview'

" Viewer and finder for LSP symbols and tags
Plug 'liuchengxu/vista.vim', { 'on': ['Vista', 'Vista!!'] }

" Pretty list of showing diagnostics, telescope results and more
Plug 'folke/trouble.nvim'

" A faster version of filetype.vim
" Plug 'nathom/filetype.nvim'

" Improve startup time for Neovim by speeding up loading of lua modules
Plug 'lewis6991/impatient.nvim'

" -------------------------

" List ends here. Plugins become visible to Vim after this call
call plug#end()

" Load impatient first before any other lua module, to speed up startuptime
lua require("impatient")

" }}}

" }}}

" ----------------------------------- 3. Settings {{{

" ----------------------------------- 3.1 Options {{{

" Syntax highlighting
syntax on

" Set true colors inside nvim
set termguicolors

" Don't show the (INSERT, REPLACE, VISUAL) modes on the last line
set noshowmode

" Highlight the current line and also highlight the column @120 (ruler)
" set colorcolumn=120
set cursorline

" Set hidden to on so as to be able to change buffers without saving first
set hidden

" Set hybrid line numbers
set number relativenumber

" Set the number of columns used for line numbers
set numberwidth=1

" Insert spaces when <Tab> is pressed
set expandtab

" Controls the number of space characters inserted when pressing the tab key
set tabstop=4

" Controls the number of space characters inserted for identation
set shiftwidth=4

" Use the indentation level of the previous line when pressing enter
set autoindent

" Enable automatic C/C++ program indenting with the following options:
" NOTE: These options will only apply when `cindent` is on, happens automatically for C-like files
" gN: sets the indentation of scope declarations like public, private, protected
" :N: sets the indentation for case labels inside switch statements
" lN: align with a case label instead of the statement after it in the same line
" NN: sets the indentation of content inside namespaces
" (N: sets the indentation when in unclosed parentheses to line up vertically
" wN: when in unclosed parentheses line up with the first character rather than the first non-white character
" WN: sets the indentation when in unclosed parentheses of the following line N characters relative to the outer context
set cinoptions=g0,:0,l1,N-s,(0,w1,W1s

" Set the visual character to be shown for wrapped lines
" set showbreak=\ \\_
set showbreak=↪\

" This makes searches case insensitive
set ignorecase

" This makes searches with a single capital letter to be case sensitive
set smartcase

" This highlights the search pattern as you type
set incsearch

" This provides live feedback when substituting
set inccommand=split

" Open new splits/windows always below and right
set splitbelow splitright

" Set automatic wrap to display lines in next line (this is the default)
set wrap

" Set the maximum text width before vim automatically wraps it, this inserts the EOL character
" This is considered a hard-wrap, one can use linebreak to soft-wrap the lines w/o inserting EOL
set textwidth=120

" Set default encoding
set encoding=UTF-8

" Set the fileformat to unix because windows line endings are bad
set fileformat=unix

" This is used to control the Ctrl + C command and copy to the system's clipboard
set clipboard^=unnamed,unnamedplus

" This option will render characters for spaces, tabs etc
" set listchars=trail:·,tab:»·,eol:↲,nbsp:␣,extends:⟩,precedes:⟨
" set listchars=eol:↴,¬,
set list
set listchars=nbsp:␣,extends:⟩,precedes:⟨,trail:·,tab:»·

" The number of lines to show above/below when navigating
set scrolloff=5

" This sets the folding method, the default markers are {{{  }}}
set foldmethod=marker

" Set fold enabled
set foldenable

" Foldopen dictates how folds open, jump means it will open with 'gg', 'G'
set foldopen+=jump

" Enable mouse support
set mouse=a

" Enable modeline to allow file secific settings
" e.g. vim: set sw=2:
set modeline

" Make updates happen faster
set updatetime=300

" Keep windows equal in size after split, close etc
set equalalways

" Set transparency for the popup window
set pumblend=15

" Set pop-up menu height
set pumheight=12

" Set completeopt to have a better completion experience
set completeopt=menu,noinsert,noselect

" Avoid showing message extra message when using completion
set shortmess+=c

" Disable swap files
set noswapfile

" Set window's title to the value of the titlestring
set title

" Set rg as the grep program
if executable('rg')
  set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case
  set grepformat=%f:%l:%c:%m,%f:%l:%m
endif

" }}}

" ----------------------------------- 3.2 Colorscheme {{{

" Convenient function to set-up onedark colorscheme
function! s:SetOneDarkColorScheme() abort
  if !functions#PluginLoaded('onedark.nvim')
    echoerr "Error: 'onedark.nvim' colorscheme has not been installed or loaded!"
    return
  endif
lua<<EOF
-- Setup onedark
require'onedark'.setup {
  transparent = false,
  dark_sidebar = true,
  dark_float = true,
  msg_area_style = "bold",
  sidebars = {
    "vista_kind",
    "terminal",
  },
  colors = {
    border_highlight = "#5c6370",
  },
  keyword_style = "NONE",
}
EOF
  " This needs to be set if we want to show the eol character
  " highlight! link NonText WhiteSpace
  " Set the promptPrefix color to purple
  highlight TelescopePromptPrefix guibg=#282c34 guifg=#c678dd
  " Re-set the color for the folded sections
  highlight Folded guibg=Black guifg=DarkGray
endfunction

" Function to setup NightFoxColorScheme
function! s:SetNightfoxColorScheme() abort
lua<<EOF
-- Setup nightfox
local nightfox = require'nightfox'
nightfox.setup {
  fox = "nordfox",
}
nightfox.load()
EOF
endfunction

" Convenient commands to set-up my colorschemes
command! OneDarkColorScheme call s:SetOneDarkColorScheme()
command! NightFoxColorScheme call s:SetNightfoxColorScheme()

" The default colorscheme to use
let s:_colorScheme='nightfox.nvim'

if functions#PluginLoaded('onedark.nvim') && s:_colorScheme=='onedark.nvim'
  call s:SetOneDarkColorScheme()
elseif functions#PluginLoaded('nightfox.nvim') && s:_colorScheme=='nightfox.nvim'
  call s:SetNightfoxColorScheme()
elseif functions#PluginLoaded('darcula') && s:_colorScheme=='darcula'
  colorscheme darcula
endif

" Darcula better highlights for diff
if functions#ColorschemeActive('darcula')
  hi DiffAdded         guifg=#499C54
  hi DiffRemoved       guifg=#ab4b52
endif

" }}}

" }}}

" ----------------------------------- 4. Autocommands {{{

" Autocmd group for generic autocommands
augroup GenericGroup
  " Clear old autocommands of this group
  autocmd!

  " Format options configuration:
  " 't': is required in format options to wrap text in insert mode
  " 'l': a line that is longer than textwidth may not be wraped if 'l' is in format options
  " 'r': enables the <CR> key from autocommenting when pressing enter in line that contains a comment, enables javadoc
  " 'o': don't insert comment when pressing 'o' or 'O'
  " 'q': allow formatting comments with gq
  autocmd BufEnter * set fo+=t fo+=r fo-=l fo-=o fo+=q

  " Remove trailing whitespaces on file save
  autocmd BufWritePre * call functions#TrimTrailingWhitespace()

  " This is used to preserve the clipboard when vim exits
  autocmd VimLeave * call system("xclip -selection clipboard -i", getreg("+"))

  " This will automatically resize windows/splits when resizing host window
  autocmd VimResized * wincmd =
augroup END

" Autocmd for adding spelling and wrapping for specific filetypes
augroup SpellWrapGroup
  " Clear old autocommands of this group
  autocmd!
  " Enable spelling and wrapping when doing a commit message or writing to a markdown file
  autocmd FileType gitcommit,markdown setlocal spell wrap
augroup END

" Autocmd for highlighting yanked text
augroup LuaHighlightGroup
  " Clear old autocommands of this group
  autocmd!
  " Enable highlighting when yanking text
  autocmd TextYankPost * silent! lua vim.highlight.on_yank()
augroup END

" Autocmd configurations for :term
augroup TermGroup
  " Clear old autocommands of this group
  autocmd!
  " Automatically enter in insert mode when in terminal pane
  autocmd TermOpen,BufEnter,WinEnter * if &buftype == 'terminal' | :startinsert | endif
  " Disable linenumbering when in terminal
  autocmd TermOpen * setlocal nonumber norelativenumber
augroup END

" Autocommands group for plugins
augroup PluginsGroup
  " Clear old autocommands for this group
  autocmd!

  if functions#PluginLoaded('nvim-lightbulb')
    autocmd CursorHold,CursorHoldI * lua require'nvim-lightbulb'.update_lightbulb{ sign = { enabled = true } }
  endif

  if functions#PluginLoaded('blamer.nvim')
    autocmd VimEnter * :BlamerHide
  endif

  if functions#PluginLoaded('vim-eunuch')
    autocmd VimEnter * :delcommand SudoWrite | :delcommand SudoEdit
  endif
augroup END

" }}}

" ----------------------------------- 5. Extra configurations {{{

" Add persistent undo for vim
" ---------------------------
if has('persistent_undo')
  " Define the paths to store the persistent undo files
  let vim_path=expand('$HOME/.vim')
  let undo_path=expand('$HOME/.vim/undo-dir')
  " Create the required directories if needed with the appropriate permissions
  if !isdirectory(vim_path)
    call mkdir(vim_path, "", 0770)
  endif
  if !isdirectory(undo_path)
    call mkdir(undo_path, "", 0700)
  endif
  " Point vim to the defined undo directory and enable undo persistence
  let &undodir=undo_path
  set undofile
endif

" }}}

" ----------------------------------- 6. Keybindings {{{

" Keymap to source the vimrc automatically
nnoremap <silent> <leader>sc :source $MYVIMRC<CR>

" Toggle Goyo - distraction free writing
nnoremap <silent> <F1> :Goyo<CR>

" Toggle between folds
nnoremap <expr> <F2> &foldlevel ? 'zM' :'zR'

" Fill the current line with a leading "<Space><prev_line_cols>[-]
nnoremap <expr> <F3> ':call functions#Fill(45)\<CR>'

" Change buffers quickly
nnoremap <silent> <leader>bn :bnext<CR>
nnoremap <silent> <leader>bp :bprevious<CR>

nnoremap <silent> <Tab>   :bnext<CR>
nnoremap <silent> <S-Tab> :bprevious<CR>

" Close the current buffer
nnoremap <silent> <leader>bd :bdelete<CR>

" List buffers and prepend :b on the cmd line
nnoremap <leader>bf :ls<CR>:b<Space>

" Close all buffers except the current one
nnoremap <silent> <leader>bo :BufOnly<CR>

" Search within buffers and send results in the qflist
" nnoremap <leader>bs :cex []<Bar>bufdo vimgrepadd @@g %<Bar>cw<S-Left><S-Left><Right>
nnoremap <leader>bs :cex []<Bar>bufdo vimgrepadd //gj %<Bar>Trouble quickfix<S-Left><S-Left><S-Left><Right>

" Split comma separated arguments of function from one-line-all to one-line-each
" f)%:       finds the starting '(' of the function signature
" csbb:      changes surround blockwise from ( to ( on its own line
" s/,/,\r/g: substitutes each ',' with ',' and carriage return '\r', one-arg-per-line
" J:         joins the last ')' to the last argument
" vib=:      select the surrounding text inside '()' and indent it visually
map <leader>bp f)%cSbbj:s/,/,\r/g<CR>Jvib=<CR>

" Typing %% on the command line will expand to active buffer's path
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Use space to toggle fold
nnoremap <Space> za<CR>

" Keybinds to move lines up and down
nnoremap <silent> <C-S-Up>   :m-2<CR>==
nnoremap <silent> <C-S-Down> :m+<CR>==
inoremap <silent> <C-S-Up>   <Esc>:m-2<CR>==gi
inoremap <silent> <C-S-Down> <Esc>:m+<CR>==gi
vnoremap <silent> <C-S-Up>   :m '<-2<CR>gv=gv
vnoremap <silent> <C-S-Down> :m '>+1<CR>gv=gv

nnoremap <silent> <C-k> :m-2<CR>==
nnoremap <silent> <C-j> :m+<CR>==
vnoremap <silent> <C-k> :m '<-2<CR>gv=gv
vnoremap <silent> <C-j> :m '>+1<CR>gv=gv

" Duplicate the current line
" 't' command is a synonym for copy
nnoremap <silent> <leader>d :t.<CR>
inoremap <silent> <leader>d <Esc>:t.<CR>
vnoremap <silent> <leader>d :t.<CR>

" Hitting ESC when inside a :term to get into normal mode
tnoremap <Esc> <C-\><C-N>

" Save files with ctrl+s
" Use :update instead of :write, to only write the file when modified
nnoremap <silent> <C-s> :update<CR>
inoremap <silent> <C-s> <Esc>:update<CR>
vnoremap <silent> <C-s> <Esc>:update<CR>

" Keymaps to quit current buffer with ctrl+q
nnoremap <silent> <C-q> :q<CR>
inoremap <silent> <C-q> <Esc>:q<CR>
vnoremap <silent> <C-q> <Esc>:q<CR>

" Keymap to quit all buffers with shift+q
nnoremap <silent> Q <Esc>:qa<CR>

" Quick movements in Insert mode without having to change to Normal mode
inoremap <C-h> <C-o>h
inoremap <C-l> <C-o>l
inoremap <C-j> <C-o>j
inoremap <C-k> <C-o>k
inoremap <C-b> <C-o>B
inoremap <C-e> <C-o>E<C-o>l
inoremap <C-a> <C-o>A
inoremap <C-^> <C-o><C-^>

" Keep Visual mode selection when indenting text
xmap > >gv
xmap < <gv

" Make visual pasting a word to not update the unnamed register
" Thus, allowing us to repeatedly paste the word. {"_ : black-hole register}
vnoremap p "_dP

" The '&' command repeats last substitution and the
" second '&' keeps the previous flags that were used
" So, usually we want to have this as the default behavior
nnoremap & :&&<CR>
xnoremap & :&&<CR>

" Remind myself to stop using the god damn arrow keys
nnoremap <silent> <Left>  :echoe "Use h"<CR>
nnoremap <silent> <Right> :echoe "Use l"<CR>
nnoremap <silent> <Up>    :echoe "Use k"<CR>
nnoremap <silent> <Down>  :echoe "Use j"<CR>
vnoremap <silent> <Left>  :<C-u>echoe "Use h"<CR>
vnoremap <silent> <Right> :<C-u>echoe "Use l"<CR>
vnoremap <silent> <Up>    :<C-u>echoe "Use k"<CR>
vnoremap <silent> <Down>  :<C-u>echoe "Use j"<CR>

" Clear highlighting with escape when in normal mode
" https://stackoverflow.com/a/1037182/6654329
nnoremap <silent> <Esc> :noh<return><Esc>
nnoremap <silent> <Esc>^[ <Esc>^[

" Commands/Keymaps to open terminals horizontally and vertically
command! -nargs=* HT split  | terminal <args>
command! -nargs=* VT vsplit | terminal <args>

nnoremap <silent> <leader>ht :HT<CR>
nnoremap <silent> <leader>vt :VT<CR>

" Make a whole-word search with <leader>/
command! -nargs=1 SearchWord call functions#SearchWord(<f-args>)
nnoremap <leader>/ :SearchWord<Space>

" Command and key mapping to enable the zoom-in and zoom-out
command! ZoomToggle call functions#ZoomToggle()
nnoremap <silent> <leader>z :ZoomToggle<CR>

" Change the default mouse scrolling wheel options
nnoremap <ScrollWheelUp>   4<C-y>
nnoremap <ScrollWheelDown> 4<C-e>
xnoremap <ScrollWheelUp>   4<C-y>
xnoremap <ScrollWheelDown> 4<C-e>

" Set a mark when moving more than 5 lines upwards/downards
" this will populate the jumplist enabling us to jump back with Ctrl-O
nnoremap <expr> k (v:count > 5 ? "m'" . v:count : "") . 'k'
nnoremap <expr> j (v:count > 5 ? "m'" . v:count : "") . 'j'

" Insert newlines below and above
nnoremap <silent> <leader>o o<Esc>kO<Esc>j

" Easiliy toggle comments
map  <leader><leader> gcc
vmap <leader><leader> gc
imap <leader><leader> <C-o><Cmd>lua require'Comment'.toggle()<CR>

" Keybindings to toggle and kill the floating term window
nnoremap <silent> <leader>ft :FloatermToggle<CR>
nnoremap <silent> <leader>fk :FloatermKill<CR>
tnoremap <silent> <leader>ft <C-\><C-n>:FloatermToggle<CR>
tnoremap <silent> <leader>fk <C-\><C-n>:FloatermKill<CR>

" Open git-messenger
nmap <silent> <leader>gm <Plug>(git-messenger)

" EasyAlign keybindings
" 'vipga' starts interactive EasyAlign in visual mode
" 'gaip' starts interactive EasyAlign for text/motion object
nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)
nmap <leader>ga <Plug>(LiveEasyAlign)
xmap <leader>ga <Plug>(LiveEasyAlign)

" Use <Tab> and <S-Tab> to navigate through the autocomplete options
inoremap <silent> <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <silent> <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" Alternate between header/source files
" nnoremap <silent> <leader>ko :Alternate<CR>
nnoremap <silent> <leader>ko :ClangdSwitchSourceHeader<CR>

" Git blame keybind toggle
nnoremap <silent> <leader>gb :BlamerToggle<CR>

" Also, '[q', ']q' work for cprev cnext, from vim-unimpaired
nnoremap <silent> <leader>co :copen<CR>
nnoremap <silent> <leader>cc :cclose<CR>
nnoremap <silent> <leader>cr :cexpr []<CR>

" Also '[l', ']l' work for lprev lnext, from vim-unimpaired
nnoremap <silent> <leader>lo :lopen<CR>
nnoremap <silent> <leader>lc :lclose<CR>
nnoremap <silent> <leader>lr :lexpr []<CR>

" Toggle quickfix and locationlist
nnoremap <silent> <leader>ct :call functions#ToggleList('qf')<CR>
nnoremap <silent> <leader>lt :call functions#ToggleList('loc')<CR>

" Keybindings to toggle Vista and open Vista finder more easily
nnoremap <silent> <leader>vv :Vista!!<CR>
nnoremap <silent> <leader>vf :Vista finder nvim_lsp<CR>

" Nvim-tree toggle keybinding
nnoremap <silent> <leader>nt :NvimTreeToggle<CR>
nnoremap <silent> <leader>nf :NvimTreeFindFile<CR>

" }}}

" ----------------------------------- 7. Abbreviations {{{

" Shebang abbreviation for bash in scripts
iab #! #!/usr/bin/env bash

" Add current date
iab <silent> idt Date: <C-R>=strftime('%c')<CR>

" Add Lua heredoc
iab lua< lua<<EOF<CR><CR>EOF<Up>

" }}}

" ---------------------------------- 8. Plugins extras {{{

" ----------------------------------- 1. Plugin options {{{

" Committia options
" -----------------
" Committia plugin minimum width before falling back to single-col layout
let g:committia_min_window_width=140

" Goyo options
" ------------
" Goyo window configurations
let g:goyo_width="80%"
let g:goyo_height="85%"
let g:goyo_linenr=0

" Vim-Signify options
" -------------------
" Show text in the sign-column '!' '-' '+'
let g:signify_sign_show_text=1

" Change the delete sign of git-signify from '_' to '-'
let g:signify_sign_delete='-'

" Vim Current Word options
" ------------------------
" Do not highlight the word under cursor
let g:vim_current_word#highlight_current_word=0

" Highlight only focused window
let g:vim_current_word#highlight_only_in_focused_window=1

" Suda options
" ------------
" Automatically open files with sudo when needed
let g:suda_smart_edit=1

" Git blamer optionss
" -------------------
" Enable plugin and set the delay before triggering
let g:blamer_enabled=1
let g:blamer_delay=500

" Startify options
" ----------------
" Specify where to store sessions
let g:startify_session_dir='~/.vim/sessions'

" Automatically update sessions
let g:startify_session_persistence=1

" Use unicode for startify
let g:startify_fortune_use_unicode=1

" Center the header
let g:startify_custom_header='startify#center(startify#fortune#cowsay())'

" Add custom bookmarks
let g:startify_bookmarks=[{'v': '~/.vimrc'}, {'z': '~/.zshrc'}, {'a': '~/.zsh_aliases'}]

" Indent-blankline options
" ------------------------
" Change the highlight for the treesitter context, to a light gray
" highlight IndentBlanklineContextChar guifg=#545c82 gui=nocombine

" Git-messenger options
" ---------------------
" Do not allow plugin defined mappings
let g:git_messenger_no_default_mappings=v:true

" Insert cursor inside pop-up window
let g:git_messenger_always_into_popup=v:true

" Added shadow to the pop-up window
let g:git_messenger_floating_win_opts={'border': 'shadow'}

" Quick-scope options
" -------------------
" Only highlight when pressing these keys
let g:qs_highlight_on_keys=['f', 'F', 't', 'T']

" Vim-rooter options
" ------------------
" Start Rooter manually instead of automatically
let g:rooter_manual_only=1

" Vem-tabline options
" -------------------
" Always show the tabline
let g:vem_tabline_show=2

" Use multiwindow mode for tabline
let g:vem_tabline_multiwindow_mode=v:true

" Show numbers on the buffer tab
let g:vem_tabline_show_number="buffnr"

" Symbol to show after the number
let g:vem_tabline_number_symbol=" "

" Change the colors of the bufferline for onedark
if functions#ColorschemeActive('onedark')
  highlight VemTablineSelected       guifg=#282c34 guibg=#c678dd
  highlight VemTablineNumberSelected guifg=#282c34 guibg=#c678dd
endif

" Vista options
" -------------
" How each level is indented and what to prepend.
" This could make the display more compact or more spacious. e.g., more compact: ["▸ ", ""]
let g:vista_icon_indent=["╰─▸ ", "├─▸ "]

" Executive used when opening vista sidebar without specifying it.
" See all the avaliable executives via `:echo g:vista#executives`.
let g:vista_default_executive='nvim_lsp'

" Set the executive for some filetypes explicitly. Use the explicit executive
" instead of the default one for these filetypes when using `:Vista` without
" specifying the executive.
let g:vista_executive_for={'cpp': 'nvim_lsp'}

" To enable fzf's preview window set g:vista_fzf_preview.
let g:vista_fzf_preview=['right:50%']

" Enable icons
let g:vista#renderer#enable_icon=1

" How to show detailed information of current cursor symbol in Vista
let g:vista_echo_cursor_strategy='floating_win'

" Vim alternate options
" ---------------------
if functions#PluginLoaded('vim-alternate')
  " Set the alternate extension mappings
  let g:AlternateExtensionMappings=[{'.cpp' : '.h', '.h' : '.hpp', '.hpp' : '.cpp'},
        \ {'.c': '.h', '.h': '.c'}, {'.cc': '.h', '.h': '.hpp', '.hpp': '.cc'}]
endif

" Vim surround options
" --------------------
if functions#PluginLoaded('vim-surround')
  " Set extra custom replacement rule that surrounds <text> with /*<text>*/
  " 120 denotes the nr2char key which corresponds to 'x'
  let g:surround_120="/*\r*/"
endif

" }}}

" ----------------------------------- 2. Plugin configurations {{{

" ----------------------------------- 0. Simple lua plugins {{{

if functions#PluginLoaded('nvim-colorizer')

lua<<EOF
-- Setup nvim-colorizer
require'colorizer'.setup()
EOF

endif

if functions#PluginLoaded('lualine.nvim')

  " Load a custom lualine theme
  " https://gist.githubusercontent.com/hoob3rt/b200435a765ca18f09f83580a606b878/raw/d99388470ed5ddb1da32a0bd3bccd4a69eb15429/evil_lualine.lua
  luafile ~/.vim/plugged/lualine.nvim/lua/lualine/themes/evil_lualine.lua

endif

if functions#PluginLoaded('LuaSnip')

  " Lazy load the plugins
  lua require'luasnip.loaders.from_vscode'.lazy_load()

endif

"}}}

" ----------------------------------- 1. Which-key {{{

if functions#PluginLoaded('vim-which-key')

  " Map leader-space to which_key
  nnoremap <silent> <leader><Space> :silent <c-u> :silent WhichKey '<Space>'<CR>
  vnoremap <silent> <leader><Space> :silent <c-u> :silent WhichKeyVisual '<Space>'<CR>

  " Create map to add keys to
  let g:which_key_map={}

  " Define a separator
  let g:which_key_sep='→'

  " Not a fan of floating windows for this
  let g:which_key_use_floating_win=0

  " Change the colors if you want
  highlight default link WhichKey          Operator
  highlight default link WhichKeySeperator DiffAdded
  highlight default link WhichKeyGroup     Identifier
  highlight default link WhichKeyDesc      Function

  " Hide status line
  autocmd! FileType which_key
  autocmd  FileType which_key set laststatus=0 noshowmode noruler
    \| autocmd BufLeave <buffer> set laststatus=2 noshowmode ruler

  " Single mappings
  let g:which_key_map['/'] = [ 'gcc',       'comment' ]
  let g:which_key_map['e'] = [ ':e .',      'explorer' ]
  let g:which_key_map['f'] = [ ':Files',    'search files' ]
  let g:which_key_map['R'] = [ ':Rg',       'search text' ]
  let g:which_key_map['S'] = [ ':Startify', 'start screen' ]
  let g:which_key_map['z'] = [ ':Goyo',     'zen' ]

  " s is for search
  let g:which_key_map.s = {
        \ 'name' : '+Search' ,
        \ '/' : [':History/'   , 'history'],
        \ ':' : [':Commands'   , 'commands'],
        \ 'b' : [':BLines'     , 'current buffer'],
        \ 'B' : [':Buffers'    , 'open buffers'],
        \ 'c' : [':Commits'    , 'commits'],
        \ 'C' : [':BCommits'   , 'buffer commits'],
        \ 'f' : [':Files'      , 'files'],
        \ 'g' : [':GFiles'     , 'git files'],
        \ 'G' : [':GFiles?'    , 'modified git files'],
        \ 'h' : [':History'    , 'file history'],
        \ 'H' : [':History:'   , 'command history'],
        \ 'l' : [':Lines'      , 'lines'],
        \ 'L' : [':Ls'         , 'ls'],
        \ 'm' : [':Marks'      , 'marks'],
        \ 'M' : [':Maps'       , 'normal maps'],
        \ 'p' : [':Helptags'   , 'help tags'],
        \ 'P' : [':Tags'       , 'project tags'],
        \ 's' : [':Snippets'   , 'snippets'],
        \ 'S' : [':Colors'     , 'color schemes'],
        \ 't' : [':Rg'         , 'text Ripgrep'],
        \ 'T' : [':BTags'      , 'buffer tags'],
        \ 'w' : [':Windows'    , 'search windows'],
        \ 'y' : [':Filetypes'  , 'file types'],
        \ 'z' : [':FZF'        , 'FZF'],
        \ }

  " b is for buffer
  let g:which_key_map.b = {
        \ 'name' : '+Buffer' ,
        \ 'a' : [':ball'       , 'one window per buffer'],
        \ 'd' : [':bd'         , 'delete-buffer'],
        \ 'f' : [':bfirst'     , 'first-buffer'],
        \ 'h' : [':Startify'   , 'home-buffer'],
        \ 'l' : [':blast'      , 'last-buffer'],
        \ 'n' : [':bnext'      , 'next-buffer'],
        \ 'o' : [':BufOnly'    , 'keep current buffer only'],
        \ 'p' : [':bprevious'  , 'previous-buffer'],
        \ '?' : [':Buffers'    , 'fzf-buffers'],
        \ }

  " w is for windows
  let g:which_key_map.w = {
        \ 'name' : '+Windows' ,
        \ '=' : ['<C-w>='   , 'equal windows'],
        \ '?' : [':Windows' , 'fzf windows'],
        \ 'd' : ['<C-W>c'   , 'delete-window'],
        \ 'h' : ['<C-W>h'   , 'window-left'],
        \ 'j' : ['<C-W>j'   , 'window-below'],
        \ 'l' : ['<C-W>l'   , 'window-right'],
        \ 'k' : ['<C-W>k'   , 'window-up'],
        \ 'r' : ['<C-w>r'   , 'rotate split'],
        \ 's' : ['<C-w>s'   , 'split below'],
        \ 'v' : ['<C-w>v'   , 'split right'],
        \}

  " g is for git
  let g:which_key_map.g = {
        \ 'name' : '+Git' ,
        \ 'b' : [':Git blame'  , 'blame'],
        \ 'B' : [':GBrowse'    , 'browse'],
        \ 'd' : [':Git diff'   , 'diff'],
        \ 'l' : [':Git log'    , 'log'],
        \ 'L' : [':Git lg'     , 'lg'],
        \ 's' : [':Gstatus'    , 'status'],
        \ 'S' : [':Git add'    , 'stage'],
        \ 'r' : [':Git reflog' , 'reflog'],
        \ }

  " p is for vim plug
  let g:which_key_map.p = {
        \ 'name' : '+Plug' ,
        \ 'c' : [':PlugClean'   , 'clean'],
        \ 'd' : [':PlugDiff'    , 'diff'],
        \ 'i' : [':PlugInstall' , 'install'],
        \ 's' : [':PlugStatus'  , 'status'],
        \ 'S' : [':PlugSnapshot', 'snapshot'],
        \ 'u' : [':PlugUpdate'  , 'update'],
        \ 'U' : [':PlugUpgrade' , 'upgrade'],
        \ }

  " t is for Telescope
  let g:which_key_map.t = {
        \ 'name' : '+Telescope' ,
        \ ':' : [':Telescope command_history'           , 'command history'],
        \ '/' : [':Telescope search_history'            , 'search history'],
        \ 'a' : [':Telescope autocommands'              , 'autocommands'],
        \ 'b' : [':Telescope buffers'                   , 'buffers'],
        \ 'B' : [':Telescope file_browser'              , 'file browser'],
        \ 'c' : [':Telescope commands'                  , 'commands'],
        \ 'C' : [':Telescope current_buffer_fuzzy_find' , 'current buffer lines'],
        \ 'f' : [':Telescope find_files'                , 'find files'],
        \ 'F' : [':Telescope filetypes'                 , 'filetypes'],
        \ 'g' : [':Telescope live_grep'                 , 'live grep'],
        \ 'h' : [':Telescope highlights'                , 'highlights'],
        \ 'j' : [':Telescope jumplist'                  , 'jumplist'],
        \ 'k' : [':Telescope keymaps'                   , 'keymappings'],
        \ 'l' : [':Telescope loclist'                   , 'location list'],
        \ 'm' : [':Telescope marks'                     , 'marks'],
        \ 'M' : [':Telescope man_pages'                 , 'man pages'],
        \ 'o' : [':Telescope oldfiles'                  , 'oldfiles'],
        \ 'O' : [':Telescope vim_options'               , 'vim options'],
        \ 'q' : [':Telescope quickfix'                  , 'quickfix list'],
        \ 's' : [':Telescope grep_string'               , 'search string'],
        \ 't' : [':Telescope tags'                      , 'tags'],
        \}

  " t.g is for Telescope git_*
  let g:which_key_map.t.g = {
        \ 'name' : '+Git' ,
        \ 'b' : [':Telescope git_bcommits' , 'buffer commmits'],
        \ 'c' : [':Telescope git_commits'  , 'commmits'],
        \ 'f' : [':Telescope git_files'    , 'git files'],
        \ 'h' : [':Telescope git_stash'    , 'git stash'],
        \ 'r' : [':Telescope git_branches' , 'git branches'],
        \ 's' : [':Telescope git_status'   , 'git status'],
        \}

  " t.l is for Telescope lsp_*
  let g:which_key_map.t.l = {
        \ 'name' : '+LSP' ,
        \ 'c' : [':Telescope lsp_code_actions'              , 'code actions'],
        \ 'C' : [':Telescope lsp_range_code_actions'        , 'range code actions'],
        \ 'd' : [':Telescope lsp_document_diagnostics'      , 'diagnostics'],
        \ 'D' : [':Telescope lsp_workspace_diagnostics'     , 'workspace diagnostics'],
        \ 'f' : [':Telescope lsp_definitions'               , 'definitions'],
        \ 'i' : [':Telescope lsp_implementations'           , 'implementations'],
        \ 'r' : [':Telescope lsp_references'                , 'references'],
        \ 's' : [':Telescope lsp_document_symbols'          , 'symbols'],
        \ 'S' : [':Telescope lsp_workspace_symbols'         , 'workspace symbols'],
        \ 'w' : [':Telescope lsp_dynamic_workspace_symbols' , 'dynamic workspace symbols'],
        \}

  " Register which key map
  call which_key#register('<Space>', "g:which_key_map")

endif

" }}}

" ----------------------------------- 2. Web-devicons {{{

if functions#PluginLoaded('nvim-web-devicons')

lua<<EOF
function _G.webDevIcons(path)
  local extension = vim.fn.fnamemodify(path, ':e')
  local filename = vim.fn.fnamemodify(path, ':t')
  return require'nvim-web-devicons'.get_icon(filename, extension, { default = true })
end
EOF

" Function for startify in-order to use web-devicons in place of devicons
function! StartifyEntryFormat() abort
  return 'v:lua.webDevIcons(absolute_path) . " " . entry_path'
endfunction

" Function for vem-tabline, to get web-devicons in place of devicons
function! WebDevIconsGetFileTypeSymbol(path) abort
  return v:lua.webDevIcons(a:path)
endfunction

endif

" }}}

" ----------------------------------- 3. Specs {{{

if functions#PluginLoaded('specs.nvim')

lua<<EOF
-- Setup specs-nvim
require'specs'.setup {
  show_jumps = true,
  min_jump = 30,
  popup = {
    inc_ms = 8,
    delay_ms = 0,
    blend = 5,
    width = 35,
    winhl = "PMenu",
    fader = require('specs').exp_fader,
    resizer = require('specs').shrink_resizer
  },
  ignore_buftypes = {
    nofile = true,
  },
  ignore_filetypes = {
    vim = true,
  }
}
EOF

endif

" }}}

" ----------------------------------- 4. FZF {{{

if functions#PluginLoaded('fzf.vim')

  " Custom fzf keybindings for searching
  " nnoremap <silent> <leader>fb :Buffers<CR>
  " nnoremap <silent> <leader>ff :Files<CR>
  " nnoremap <silent> <leader>rg :Rg<CR>
  " nnoremap <silent> <leader>fM :Marks<CR>
  " nnoremap <silent> <leader>fh :History:<CR>
  " nnoremap <silent> <leader>fm <Cmd>Maps<CR>

  " Open mappings depending on what mode we're currently using
  nmap <silent> <leader>fm <Plug>(fzf-maps-n)
  imap <silent> <leader>fm <Plug>(fzf-maps-i)
  xmap <silent> <leader>fm <Plug>(fzf-maps-x)

  " Start searching for files
  command! -bang -nargs=? -complete=dir Files
    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)

  " Execeute ls on the specified directory
  command! -bang -complete=dir -nargs=? Ls
    \ call fzf#run(fzf#wrap({'source': 'ls', 'dir': <q-args>}, <bang>0))

  " Custom RipgrepFzf function to use with Rg command
  function! RipgrepFzf(query, fullscreen)
    let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
    let initial_command = printf(command_fmt, shellescape(a:query))
    let reload_command = printf(command_fmt, '{q}')
    " Make a centered pop-up window for Rg
    let spec = { 'window': { 'width': 0.9, 'height': 0.7 },
                \'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command] }
    call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
  endfunction

  " Start an interactive Ripgrep search
  command! -nargs=* -bang Rg call RipgrepFzf(<q-args>, <bang>0)

  " Make FZF colors match the active colorscheme
  let g:fzf_colors = {
        \ 'fg'      : ['fg', 'Normal'],
        \ 'bg'      : ['bg', 'Normal'],
        \ 'hl'      : ['fg', 'Comment'],
        \ 'fg+'     : ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
        \ 'bg+'     : ['bg', 'CursorLine', 'CursorColumn'],
        \ 'hl+'     : ['fg', 'Statement'],
        \ 'info'    : ['fg', 'PreProc'],
        \ 'border'  : ['fg', 'Ignore'],
        \ 'prompt'  : ['fg', 'Conditional'],
        \ 'pointer' : ['fg', 'Exception'],
        \ 'marker'  : ['fg', 'Keyword'],
        \ 'spinner' : ['fg', 'Label'],
        \ 'header'  : ['fg', 'Comment']
        \}

  " Popup window (anchored to the bottom of the current window)
  " https://github.com/junegunn/fzf/blob/master/README-VIM.md
  let g:fzf_layout = {
        \ 'window':  {
          \ 'width'    : 1.0,
          \ 'height'   : 0.30,
          \ 'relative' : v:true,
          \ 'yoffset'  : 1.0,
          \ 'border'   : 'horizontal',
          \}
        \}

  " This is the default extra key bindings
  let g:fzf_action = {
        \ 'ctrl-t' : 'tab split',
        \ 'ctrl-x' : 'split',
        \ 'ctrl-v' : 'vsplit'
        \}

endif

" }}}

" ----------------------------------- 5. Tree sitter {{{

if functions#PluginLoaded('nvim-treesitter')

lua<<EOF
-- Setup nvim-treesitter
require'nvim-treesitter.configs'.setup {
  ensure_installed = {
    "bash", "c", "cpp", "cmake", "comment", "css", "html", "javascript",
    "json", "lua", "python", "typescript", "tsx", "vim"
  },
  autopairs = {
    enable = true,
  },
  autotag = {
    enable = true,
  },
  context_commentstring = {
    enable = true,
    enable_autocmd = false,
  },
  highlight = {
    enable = true,
    custom_captures = {},
    additional_vim_regex_highlighting = false,
  },
  indent = {
    enable = true,
    disable = { "c", "cpp" },
  },
  incremental_selection = {
    enable = true,
    keymaps = {
      init_selection    = "gis",
      node_incremental  = "ni",
      node_decremental  = "nd",
      scope_incremental = "si",
    }
  },
  textobjects = {
    select = {
      enable = true,
      lookahead = true, -- Automatically jump forward to textobj, similar to targets.vim
      keymaps = {
        ["af"] = "@function.outer",
        ["if"] = "@function.inner",
        ["al"] = "@loop.outer",
        ["il"] = "@loop.inner",
        ['ac'] = '@conditional.outer',
        ['ic'] = '@conditional.inner',
        ["aC"] = "@class.outer",
        ["iC"] = "@class.inner",
      },
    },
    swap = {
      enable = true,
      swap_next = {
        ["<leader>sp"] = "@parameter.inner",
        ["<leader>sm"] = "@function.outer",
      },
      swap_previous = {
        ["<leader>sP"] = "@parameter.inner",
        ["<leader>sM"] = "@function.outer",
      },
    },
    move = {
      enable = true,
      set_jumps = true,
      goto_next_start = {
        ["]m"] = "@function.outer",
        ["]c"] = "@class.outer",
      },
      goto_next_end = {
        ["]M"] = "@function.outer",
        ["]C"] = "@class.outer",
      },
      goto_previous_start = {
        ["[m"] = "@function.outer",
        ["[c"] = "@class.outer",
      },
      goto_previous_end = {
        ["[M"] = "@function.outer",
        ["[C"] = "@class.outer",
      },
    },
    playground = {
      enable = true,
      updatetime = 25,
      persist_queries = false,
      keybindings = {
        toggle_query_editor = 'o',
        toggle_hl_groups = 'i',
        toggle_injected_languages = 't',
        toggle_anonymous_nodes = 'a',
        toggle_language_display = 'I',
        focus_language = 'f',
        unfocus_language = 'F',
        update = 'R',
        goto_node = '<cr>',
        show_help = '?',
      },
    },
  },
}
EOF

endif

" }}}

" ----------------------------------- 6. Trouble {{{

if functions#PluginLoaded('trouble.nvim')

  " Trouble list command-line sugar
  nnoremap <silent> <leader>tt :TroubleToggle<CR>
  nnoremap <silent> <leader>tw :TroubleToggle workspace_diagnostics<CR>
  nnoremap <silent> <leader>td :TroubleToggle document_diagnostics<CR>
  nnoremap <silent> <leader>tq :TroubleToggle quickfix<CR>
  nnoremap <silent> <leader>tl :TroubleToggle loclist<CR>
  nnoremap <silent> <leader>tr :TroubleToggle lsp_references<CR>

lua<<EOF
-- Setup trouble
require'trouble'.setup {
  position = "bottom",                 -- position of the list can be: bottom, top, left, right
  height = 18,                         -- height of the trouble list when position is top or bottom
  width = 50,                          -- width of the list when position is left or right
  icons = true,                        -- use devicons for filenames
  mode = "document_diagnostics",        -- "lsp_workspace_diagnostics", "quickfix", "lsp_references", "loclist"
  fold_open = "",                     -- icon used for open folds
  fold_closed = "",                   -- icon used for closed folds
  group = true,                        -- groupe results by file
  padding = true,                      -- add an extra new line on top of the list
  action_keys = {                      -- key mappings for actions in the trouble list
    close = "q",                       -- close the list
    cancel = "<esc>",                  -- cancel the preview and get back to your last window / buffer / cursor
    refresh = "r",                     -- manually refresh
    jump = { "<cr>", "<tab>", "o" },   -- jump to the diagnostic or open / close folds
    jump_close = { "oc", "go" },       -- jump to the diagnostic and close the list
    open_split = { "<c-x>" },          -- open buffer in new split
    open_vsplit = { "<c-v>" },         -- open buffer in new vsplit
    open_tab = { "<c-t>" },            -- open buffer in new tab
    toggle_mode = "m",                 -- toggle between "workspace" and "document" diagnostics mode
    toggle_preview = "P",              -- toggle auto_preview
    hover = "K",                       -- opens a small poup with the full multiline message
    preview = "p",                     -- preview the diagnostic location
    close_folds = { "zM", "zm" },      -- close all folds
    open_folds = { "zR", "zr" },       -- open all folds
    toggle_fold = { "<Space>", "za" }, -- toggle fold of current file
    previous = "<C-k>",                -- previous item
    next = "<C-j>",                    -- next item
  },
  indent_lines = true,                 -- add an indent guide below the fold icons
  auto_open = false,                   -- automatically open the list when you have diagnostics
  auto_close = false,                  -- automatically close the list when you have no diagnostics
  auto_preview = true,                 -- automatically preview the location of the diagnostic
  auto_fold = false,                   -- automatically fold a file trouble list at creation
  auto_jump = { "lsp_definitions" },   -- for the given modes, automatically jump if there is only a single result
  signs = {
    error       = "",
    information = "",
    warning     = "",
    hint        = "",
    other       = "﫠"
  },
  use_lsp_diagnostic_signs = false    -- enabling this will use the signs defined in your lsp client
}
EOF

endif

"}}}

" ----------------------------------- 7. Telescope {{{

if functions#PluginLoaded('telescope.nvim')

  " Find files using Telescope command-line sugar
  nnoremap <silent> <leader>fb <Cmd>Telescope buffers<CR>
  nnoremap <silent> <leader>fc <Cmd>Telescope commands<CR>
  nnoremap <silent> <leader>ff <Cmd>Telescope find_files<CR>
  nnoremap <silent> <leader>fF <Cmd>Telescope git_files<CR>
  nnoremap <silent> <leader>fH <Cmd>Telescope highlights<CR>
  nnoremap <silent> <leader>fo <Cmd>Telescope oldfiles<CR>
  nnoremap <silent> <leader>fO <Cmd>Telescope vim_options<CR>
  nnoremap <silent> <leader>fw <Cmd>Telescope grep_string<CR>
  nnoremap <silent> <leader>fT <Cmd>Telescope tags<CR>
  nnoremap <silent> <leader>fs <Cmd>Telescope lsp_document_symbols<CR>
  nnoremap <silent> <leader>f: <Cmd>Telescope command_history<CR>
  nnoremap <silent> <leader>f/ <Cmd>Telescope search_history<CR>

  " Custom commands with extra options
  nnoremap <silent> <leader>fg <Cmd>lua require'telescope.builtin'.live_grep({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fh <Cmd>lua require'telescope.builtin'.help_tags({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fl <Cmd>lua require'telescope.builtin'.current_buffer_fuzzy_find({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fM <Cmd>lua require'telescope.builtin'.keymaps(require'telescope.themes'.get_dropdown({}))<CR>
  nnoremap <silent> <leader>fv <Cmd>lua find_in_vim_root()<CR>

lua<<EOF
local actions = require('telescope.actions')
local actions_layout = require "telescope.actions.layout"
local trouble = require('trouble.providers.telescope')

-- Setup Telescope
require'telescope'.setup {
  defaults = {
    prompt_prefix = "❯ ",
    selection_caret = "❯ ",
    winblend = 15,
    layout_strategy = "horizontal",
    layout_config = {
      prompt_position = "bottom",
      horizontal = {
        width = { padding = 0.1 },
        height = { padding = 0.1 },
        preview_width = 0.5,
        mirror = false,
      },
      vertical = {
        width = { padding = 0.1 },
        height = { padding = 0.1 },
        preview_height = 0.65,
        mirror = false,
      },
    },
    path_display = { shorten = 5 },
    sorting_strategy = "descending",
    set_env = { ["COLORTERM"] = "truecolor" },
    mappings = {
      i = {
        -- Enable <C-w> to delete word under cursor, hoepfully this will be merged upstream by default
        -- Issue: https://github.com/nvim-telescope/telescope.nvim/issues/1579
        ["<C-w>"] = function()
          vim.api.nvim_input "<C-S-w>"
        end,
        ["<C-j>"] = actions.move_selection_next,
        ["<C-k>"] = actions.move_selection_previous,
        ["<CR>"] = actions.select_default + actions.center,
        ["<C-c>"] = actions.smart_send_to_qflist + actions.open_qflist,
        ["<C-l>"] = actions.smart_send_to_loclist + actions.open_loclist,
        ["<C-t>"] = trouble.open_with_trouble,
        ["<C-q>"] = actions.close,
        ["<M-m>"] = actions_layout.toggle_mirror,
        ["<M-p>"] = actions_layout.toggle_prompt_position,
        ["?"] = actions_layout.toggle_preview,
        -- ["<Esc>"] = actions.close,
      },
      n = {
        ["<C-j>"] = actions.move_selection_next,
        ["<C-t>"] = trouble.open_with_trouble,
        ["<C-k>"] = actions.move_selection_previous,
        ["<M-m>"] = actions_layout.toggle_mirror,
        ["<M-p>"] = actions_layout.toggle_prompt_position,
        ["?"] = actions_layout.toggle_preview,
      },
    },
  },
},

-- Load extensions
require'telescope'.load_extension('fzf')

-- Custom lua function to edit ~/.vim
function find_in_vim_root()
  require'telescope.builtin'.find_files {
    prompt_title = "~/.vim",
    cwd = "~/.vim",
    follow = true,                          -- follow symbolic links
    file_ignore_patterns = { "undo%-dir" }, -- character '-' needs to be escaped
  }
end
EOF

endif

" }}}

" ----------------------------------- 8. Nvim-cmp {{{

if functions#PluginLoaded('nvim-cmp')

lua<<EOF
-- Setup custom icons for the autocompletion
local cmp_kinds = {
  Class         = "  ",
  Color         = "  ",
  Constant      = "  ",
  Constructor   = "  ",
  Enum          = "了 ",
  EnumMember    = "  ",
  Field         = "  ",
  File          = "  ",
  Folder        = "  ",
  Function      = "ƒ  ",
  Interface     = "  ",
  Keyword       = "  ",
  Method        = "  ",
  Module        = "  ",
  Property      = "  ",
  Snippet       = "﬌  ",
  Struct        = "  ",
  Reference     = "  ",
  Text          = "  ",
  Unit          = "塞 ",
  Value         = "  ",
  Variable      = "  ",
  Operator      = "  ",
  Event         = "  ",
  TypeParameter = "  ",
}

-- Setup custom menu entries for the autocompletion
local cmp_source_names = {
  nvim_lsp = "[LSP]",
  nvim_lua = "[Lua]",
  luasnip  = "[LuaSnip]",
  path     = "[Path]",
  buffer   = "[Buffer]",
}

local cmp = require'cmp'
local luasnip = require'luasnip'

-- Functions for mapping <Tab> and <S-Tab> for nvim-cmp
local function tab(fallback)
  local has_words_before = function()
    local line, col = unpack(vim.api.nvim_win_get_cursor(0))
    return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match("%s") == nil
  end
  if cmp.visible() then
    cmp.select_next_item()
  elseif luasnip.expand_or_jumpable() then
    luasnip.expand_or_jump()
  elseif has_words_before() then
    cmp.complete()
  else
    fallback()
  end
end

local function shift_tab(fallback)
  if cmp.visible() then
    cmp.select_prev_item()
  elseif luasnip.jumpable(-1) then
    luasnip.jump(-1)
  else
    fallback()
  end
end

-- Setup nvim-cmp
cmp.setup {
  completion = {
    -- The minimum length of a word to complete on
    keyword_length = 1,
  },
  experimental = {
    ghost_text = true,
    native_menu = false,
  },
  formatting = {
    format = function(entry, vim_item)
      -- Add icons for the suggestions
      vim_item.kind = cmp_kinds[vim_item.kind]

      -- Set a name for each source
      vim_item.menu = cmp_source_names[entry.source.name]

      -- Do not add duplicate entries if an item with the same word is already present
      -- Seems to fix, the duplicate entries with the snippets
      vim_item.dup = 0

      return vim_item
    end
  },
  documentation = {
    border = { "╭", "─", "╮", "│", "╯", "─", "╰", "│" },
  },
  snippet = {
    expand = function(args)
      require'luasnip'.lsp_expand(args.body)
    end
  },
  mapping = {
    ['<CR>']      = cmp.mapping.confirm({ select = true }),
    ['<Tab>']     = cmp.mapping(tab, { "i", "s" }),
    ['<S-Tab>']   = cmp.mapping(shift_tab, { "i", "s" }),
    ['<C-d>']     = cmp.mapping.scroll_docs(-4),
    ['<C-f>']     = cmp.mapping.scroll_docs(4),
    ['<C-Space>'] = cmp.mapping.complete(),
  },
  sources = {
    { name = "nvim_lsp" },
    { name = "nvim_lua" },
    { name = "luasnip" },
    { name = "path" },
    { name = "buffer", keyword_length = 4,
      option = {
        -- Get results only from visible buffers rather than from all buffers
        get_bufnrs = function()
          local bufs = {}
          for _, win in ipairs(vim.api.nvim_list_wins()) do
            bufs[vim.api.nvim_win_get_buf(win)] = true
          end
          return vim.tbl_keys(bufs)
        end
      },
    },
  },
}
EOF

endif

" }}}

" ----------------------------------- 9. Nvim-autopairs {{{

if functions#PluginLoaded('nvim-autopairs')

lua<<EOF
-- Setup nvim-autopairs
require'nvim-autopairs'.setup {
  disable_filetype = { "TelescopePrompt", "vim" },
  check_ts = true,
}

-- Fix <CR> for nvim-cmp
local cmp_autopairs = require'nvim-autopairs.completion.cmp'
local cmp = require'cmp'
cmp.event:on('confirm_done', cmp_autopairs.on_confirm_done({  map_char = { tex = '' } }))
EOF

endif

" }}}

" ----------------------------------- 10. Goto-preview {{{

if functions#PluginLoaded('goto-preview')

lua<<EOF
-- Setup goto-preview
require'goto-preview'.setup {
  width = 120,              -- Width of the floating window
  height = 25,              -- Height of the floating window
  opacity = 5,              -- 0-100 opacity level of the floating window where 100 is fully transparent.
  debug = false,            -- Print debug information
  post_open_hook = nil,     -- A function taking two arguments, a buffer and a window to be ran as a hook.
  default_mappings = false, -- Bind default mappings
  focus_on_open = true,     -- Focus the floating window when opening it
  dismiss_on_move = false,  -- Dismiss the foloating window when moving the cursor
  resizing_mappings = true, -- Binds arrow keys to resizing the floating window
  force_close = true,       -- Force close the last window of a buffer eve with unwritten changes. See :h nvim_win_close
  bufhidden = "wipe",       -- This option specifies what happens when a buffer is no longer displayed in a window. See :h bufhidden
}

local opts = { noremap = true, silent = true }
-- These keymaps are overwriting default gp and gP for pasting and keeping cursor on new line
vim.api.nvim_set_keymap("n", "gp", "<Cmd>lua require('goto-preview').goto_preview_definition()<CR>", opts)
vim.api.nvim_set_keymap("n", "gP", "<Cmd>lua require('goto-preview').close_all_win()<CR>",           opts)
EOF

endif

" }}}

" ----------------------------------- 11. Numb {{{

if functions#PluginLoaded('numb.nvim')

lua<<EOF
-- Setup numb-nvim
require'numb'.setup {
  show_numbers = true,    -- Enable 'number' for the window while peeking
  number_only = true,     -- Peek only when the command is only a number instead of when it starts with a number
  show_cursorline = true, -- Enable 'cursorline' for the window while peeking
}
EOF

endif

" }}}

" ----------------------------------- 12. Null-ls {{{

if functions#PluginLoaded('null-ls.nvim')

lua<<EOF
-- Setup null-ls
local null_ls = require'null-ls'
null_ls.setup {
  sources = {
    -- Formatting
    null_ls.builtins.formatting.prettierd,
    null_ls.builtins.formatting.stylua,
    null_ls.builtins.formatting.clang_format.with({
      extra_args = { "-style=file" }
    }),
    null_ls.builtins.formatting.shfmt.with({
      extra_args = { "-i", "4", "-bn", "-ci", "-sr" }
    }),
    -- Diagnostics
    null_ls.builtins.diagnostics.shellcheck.with({
      diagnostics_format = "SC#{c}: #{m} (#{s})"
    })
    null_ls.builtins.diagnostics.luacheck,
  }
}
EOF

endif

" }}}

" ----------------------------------- 13. LSP {{{

lua<<EOF
-- Setup LSP configurations
local on_attach = function(client, bufnr)

  -- Syntactic sugar
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  -- Enable completion triggered by <c-x><c-o>
  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings
  local opts = { noremap = true, silent = true }
  buf_set_keymap('n', 'gD'         , '<Cmd>lua vim.lsp.buf.declaration()<CR>'                  , opts)
  buf_set_keymap('n', 'gd'         , '<Cmd>lua vim.lsp.buf.definition()<CR>'                   , opts)
  buf_set_keymap('n', 'gr'         , '<Cmd>lua vim.lsp.buf.references()<CR>'                   , opts)
  buf_set_keymap('n', 'K'          , '<Cmd>lua vim.lsp.buf.hover()<CR>'                        , opts)
  buf_set_keymap('n', '<leader>rn' , '<Cmd>lua vim.lsp.buf.rename()<CR>'                       , opts)
  buf_set_keymap('n', '<leader>ca' , '<Cmd>CodeActionMenu<CR>'                                 , opts)
  buf_set_keymap('n', '[d'         , '<Cmd>lua vim.diagnostic.goto_prev()<CR>'             , opts)
  buf_set_keymap('n', ']d'         , '<Cmd>lua vim.diagnostic.goto_next()<CR>'             , opts)
  buf_set_keymap('n', 'dp'         , '<Cmd>lua vim.diagnostic.goto_prev()<CR>'             , opts)
  buf_set_keymap('n', 'dp'         , '<Cmd>lua vim.diagnostic.goto_prev()<CR>'             , opts)
  buf_set_keymap('n', 'dn'         , '<Cmd>lua vim.diagnostic.goto_next()<CR>'             , opts)
  buf_set_keymap('n', '<leader>ll' , '<Cmd>lua vim.diagnostic.setloclist()<CR>'                , opts)
  buf_set_keymap('n', '<leader>lq' , '<Cmd>lua vim.diagnostic.setqflist()<CR>'                 , opts)
  buf_set_keymap('n', '<leader>ld' , '<Cmd>lua vim.diagnostic.open_float()<CR>'                , opts)
  buf_set_keymap('n', '<leader>fr' , '<Cmd>lua vim.lsp.buf.formatting()<CR>'                   , opts)

  -- Disable default LSP formatting as this is handled by 'null-ls' LSP
  client.resolved_capabilities.document_formatting = false
  client.resolved_capabilities.document_range_formatting = false
end

-- Make a new object describing the LSP client capabilities
local capabilities = vim.lsp.protocol.make_client_capabilities()

-- Disable LSP snippets for the time being since I do not want
-- to have duplicate snippet suggestions between LuaSnip and LSP snippets
capabilities.textDocument.completion.completionItem.snippetSupport = false
capabilities.textDocument.completion.completionItem.resolveSupport = {
  properties = {
    "documentation",
    "detail",
    "additionalTextEdits",
    },
  }

-- Add additional capabilities supported by nvim-cmp
local status_ok, cmp_nvim_lsp = pcall(require, "cmp_nvim_lsp")
if status_ok then
  capabilities = cmp_nvim_lsp.update_capabilities(capabilities)
end

-- Function to install and setup LSP servers automatically
local setup_servers = function()

  -- Nvim-lsp-installer configuration
  local lsp_installer = require'nvim-lsp-installer'

  lsp_installer.settings {
    ui = {
      icons = {
        server_installed = "✓",
        server_pending = "➜",
        server_uninstalled = "✗"
      }
    }
  }

  lsp_installer.on_server_ready(function(server)
    local opts = {
      on_attach = on_attach,
      capabilities = capabilities
    }

    -- Custom LSP server settings
    if server.name == "eslint" then
      -- Disable showDocumentation from eslint code-actions menu.
      -- The actual value seems to not be working, just setting it to any value disables the option.
      opts.settings = { codeAction = { showDocumentation = false } }
    elseif server.name == "sumneko_lua" then
      -- This option is required because of the newly introduced `single-file-mode`
      -- that doesn't work as expected atleast for me for non-git lua projects.
      -- Respective commit: https://github.com/neovim/nvim-lspconfig/commit/0d1ce78d231773046320caa45fe1a18dfa366761
      -- opts.root_dir = function(fname)
      --   local util = require "lspconfig/util"
      --   return util.root_pattern ".git"(fname) or util.path.dirname(fname)
      -- end
      opts.settings = {
        Lua = {
          diagnostics = {
            globals = { "vim" } -- Make the LSP recongize the `vim` global
          },
        }
      }
    end

    server:setup(opts)
    vim.cmd [[ do User LspAttachBuffers ]]
  end)

  -- Define the required LSP servers
  local required_servers = { "bashls", "clangd", "cmake", "eslint", "pyright", "sumneko_lua", "tsserver", "vimls" }

  -- Install missing servers
  for _, server_name in pairs(required_servers) do
    local ok, server = lsp_installer.get_server(server_name)
    if ok then if not server:is_installed() then
        print("Installing lsp_sever: " .. server_name)
        server:install()
      end
    end
  end
end

-- Setup the LSP servers
setup_servers()

-- Setup lsp-signature
require'lsp_signature'.on_attach({
  bind = true,
  doc_lines = 10,
  handler_opts = {
    border = "none",       -- double, single, shadow, none
  },
  floating_window = true, -- show hint in a floating window, set to false for virtual text only mode
  hint_enable = false,      -- virtual hint enable
  hint_prefix = " ",      -- show a prefix before the virtual text
  hint_scheme = "String",
  hi_parameter = "Search", -- parameter highlight
  toggle_key = "<M-x>",    -- togle signature on or off
})

-- Custom icons for LSP diagnostics
vim.fn.sign_define("LspDiagnosticsSignHint",        { text = "", numhl = "LspDiagnosticsDefaultHint" })
vim.fn.sign_define("LspDiagnosticsSignError",       { text = "", numhl = "LspDiagnosticsDefaultError" })
vim.fn.sign_define("LspDiagnosticsSignWarning",     { text = "", numhl = "LspDiagnosticsDefaultWarning" })
vim.fn.sign_define("LspDiagnosticsSignInformation", { text = "", numhl = "LspDiagnosticsDefaultInformation" })

-- Toggle LSP diagnostics on and off
vim.g.diagnostics_active = true
function _G.toggle_diagnostics()
  if vim.g.diagnostics_active then
    vim.g.diagnostics_active = false
    vim.diagnostic.disable()
  else
    vim.g.diagnostics_active = true
    vim.diagnostic.enable()
  end
  print("LSP diagnostics: " .. tostring(vim.g.diagnostics_active))
end

-- Consider this when another keybind sequence makes more sense, don't want to bind <leader>dd
-- vim.api.nvim_set_keymap('n', '<leader>dt', ':call v:lua.toggle_diagnostics()<CR>', { noremap = true, silent = true })
EOF

" Add a user defined command to call, instead of adding a mapping to <leader>dt
command! ToggleLSPDiagnostics call v:lua.toggle_diagnostics()

" }}}

" ----------------------------------- 14. Indent-blankline {{{

if functions#PluginLoaded('indent-blankline.nvim')

lua<<EOF
-- Setup indent-blankline
require'indent_blankline'.setup {
  -- char_list = { '|', '¦', '┆', '┊' },
  char = "│", -- Specifies the character to be used as indent line
  stricts_tabs = true, -- When on, if there is a single tab in a line, only tabs are used to calculate the indentation level
  use_treesitter = true, -- Use treesitter to calculate indentation when possible
  show_first_indent_level = false, -- Displays indentation in the first column
  show_trailing_blankline_indent = false, -- Displays a trailing indentation guide on blank lines, to match the indentation of surrounding code
  show_end_of_line = true, --  Displays the end of line character set by listchars
  show_current_context = true, -- Use treesitter to determine the current context
  show_current_context_start = true, -- Apply highlighting to the first line of current cnotext, by default will 'underline'
  show_current_context_start_on_current_line = false, -- Show context_start even when cursor is on the same line
  buftype_exclude = { "terminal" }, -- Specifies a list of buftype values for which this plugin is not enabled
  filetype_exclude = { -- Specifies a list of filetype values for which this plugin is not enabled
    "help",
    "startify",
    "gitcommit",
    "vistakind",
    "packer",
  },
  context_patterns = { -- Specifies a list of lua patterns that are used to match against treesitter
    "class",
    "function",
    "method",
    "^if",
    "^while",
    "^for",
    "^try",
    "except",
    "argument_list",
  },
}
EOF

endif

" }}}

" ----------------------------------- 15. Nvim-tree {{{

if functions#PluginLoaded('nvim-tree.lua')

lua<<EOF
-- Setup nvim-tree
vim.g.nvim_tree_quit_on_open = 1            -- closes the tree when you open a file
vim.g.nvim_tree_indent_markers = 1          -- this option shows indent markers when folders are open
vim.g.nvim_tree_git_hl = 1                  -- will enable file highlight for git attributes (can be used without the icons)
vim.g.nvim_tree_highlight_opened_files = 1  -- will enable folder and file icon highlight for opened files/directories
vim.g.nvim_tree_root_folder_modifier = ':~' -- default. See :help filename-modifiers for more options
vim.g.nvim_tree_add_trailing = 1            -- append a trailing slash to folder names
vim.g.nvim_tree_group_empty = 1             -- compact folders that only contain a single folder into one node
vim.g.nvim_tree_disable_window_picker = 0   -- will disable the window picker
vim.g.nvim_tree_icon_padding = ' '          -- used for rendering the space between the icon and the filename.
vim.g.nvim_tree_respect_buf_cwd = 1         -- will change cwd of nvim-tree to that of new buffer's when opening nvim-tree
vim.g.nvim_tree_git_hl = 0                  -- disable this for better perfomance
vim.g.nvim_tree_auto_ignore_ft = {          -- do not load nvim-tree for these filetypes
  'startify'
}
vim.g.nvim_tree_show_icons = {              -- disable/enable icons per type, disable git for better perfomance
  git = 0,
  folders = 1,
  files = 1,
  folder_arrows = 1,
}
vim.g.nvim_tree_icons = {                   -- set the desired icons to display
  default = '',
  symlink = '',
  git = {
    unstaged = "✗",
    staged = "✓",
    unmerged = "",
    renamed = "➜",
    untracked = "★",
    deleted = "",
    ignored = "◌"
  },
  folder = {
    arrow_open = "",
    arrow_closed = "",
    open = "",
    default = "",
    empty = "",
    empty_open = "",
    symlink = "",
    symlink_open = "",
  },
}

-- Custom keybindings
local tree_cb = require'nvim-tree.config'.nvim_tree_callback
local nvim_tree_bindings = {
  { key = {"<CR>", "o", "<2-LeftMouse>"}, cb = tree_cb("edit") },
  { key = {"<C-]>", "+"},                 cb = tree_cb("cd") },
  { key = "<C-v>",                        cb = tree_cb("vsplit") },
  { key = "<C-x>",                        cb = tree_cb("split") },
  { key = "<C-t>",                        cb = tree_cb("tabnew") },
  { key = "<",                            cb = tree_cb("prev_sibling") },
  { key = ">",                            cb = tree_cb("next_sibling") },
  { key = "P",                            cb = tree_cb("parent_node") },
  { key = "<BS>",                         cb = tree_cb("close_node") },
  { key = "<S-CR>",                       cb = tree_cb("close_node") },
  { key = "<Tab>",                        cb = tree_cb("preview") },
  { key = "K",                            cb = tree_cb("first_sibling") },
  { key = "J",                            cb = tree_cb("last_sibling") },
  { key = "I",                            cb = tree_cb("toggle_ignored") },
  { key = "H",                            cb = tree_cb("toggle_dotfiles") },
  { key = "R",                            cb = tree_cb("refresh") },
  { key = "a",                            cb = tree_cb("create") },
  { key = "d",                            cb = tree_cb("remove") },
  { key = "r",                            cb = tree_cb("rename") },
  { key = "<C-r>",                        cb = tree_cb("full_rename") },
  { key = "x",                            cb = tree_cb("cut") },
  { key = "c",                            cb = tree_cb("copy") },
  { key = "p",                            cb = tree_cb("paste") },
  { key = "y",                            cb = tree_cb("copy_name") },
  { key = "Y",                            cb = tree_cb("copy_path") },
  { key = "gy",                           cb = tree_cb("copy_absolute_path") },
  { key = "[c",                           cb = tree_cb("prev_git_item") },
  { key = "]c",                           cb = tree_cb("next_git_item") },
  { key = "-",                            cb = tree_cb("dir_up") },
  { key = "s",                            cb = tree_cb("system_open") },
  { key = "q",                            cb = tree_cb("close") },
  { key = "g?",                           cb = tree_cb("toggle_help") },
}

require'nvim-tree'.setup {
  disable_netrw = false,   -- disables netrw
  hijack_netrw = true,     -- prevents netrw from automatically opening when opening directories
  open_on_setup = false,   -- don't open when running setup
  ignore_ft_on_setup = {}, -- ignore filetypes when running setup
  update_to_buf_dir = {    -- hijacks new directory buffers when they are opened, opens the tree when typing `vim $DIR` or `vim`
    enable = true,
    auto_open = true,      -- open the tree if it was previsouly closed
  },
  git = {
    enable = true,         -- Enable git integration
    ignore = true,         -- Ignore files based on .gitignore
    timeout = 500,         -- Kill the git process after some time if it takes too long
  },
  auto_close = false,      -- do not close neovim when nvim-tree is the last window
  open_on_tab = true,      -- open tree automatically when switching tab or opening new one
  hijack_cursor = false,   -- when moving cursor in the tree, will position the cursor at the start of the file on the current line
  update_cwd = true,       -- update the tree cwd when changing nvim's directory (DirChanged event)
  diagnostics = {          -- lsp diagnostics in the signcolumn
    enable = false,
    icons = {
      hint = "",
      info = "",
      warning = "",
      error = "",
    }
  },
  update_focused_file = {  -- do not update tree to follow the focused file
    enable = false,
    update_cwd = false,    -- update the root directory of the tree to the one of the folder containing the file
    ignore_list = {}
  },
  system_open = {          -- configuration options for the system command, 's' in the tree by default
    cmd = nil,             -- the command to run, nil should work on most cases
    args = {}              -- the command arguments as a list
  },
  view = {                 -- configuration options for the view
    width = 45,            -- width of the window, can be either columns or string in '%'
    height = 30,           -- height of the window, can be either columns or string in '%'
    side = 'left',         -- the side where the tree should open
    auto_resize = true,    -- resize the tree when opening a file
    mappings = {
      custom_only = true,  -- disable default keybindings
      list = nvim_tree_bindings
    }
  },
  filters = {
    dotfiles = false,       -- hide files and folders starting with a dot '.'
    custom = {              -- do not load and display on these folders
      '.git',
      'node_modules',
      '.cache'
    }
  },
}
EOF

endif

" }}}

" ----------------------------------- 16. Comment {{{

if functions#PluginLoaded('Comment.nvim')

lua<<EOF
-- Setup Comment
require'Comment'.setup {
  ---Add a space b/w comment and the line
  ---@type boolean
  padding = true,

  ---Whether the cursor should stay at its position
  ---NOTE: This only affects NORMAL mode mappings and doesn't work with dot-repeat
  ---@type boolean
  sticky = true,

  ---Lines to be ignored while comment/uncomment
  ---Could be a regex string or a function that returns a regex string
  ---@type string|function
  ignore = '^$',

  ---Create basic (operator-pending) and extended mappings for NORMAL + VISUAL mode
  ---@type table
  mappings = {
    ---operator-pending mapping
    ---Includes `gcc`, `gcb`, `gc[count]{motion}` and `gb[count]{motion}`
    basic = true,
    ---extra mapping
    ---Includes `gco`, `gcO`, `gcA`
    extra = true,
    ---extended mapping
    ---Includes `g>`, `g<`, `g>[count]{motion}` and `g<[count]{motion}`
    extended = false,
  },

  ---LHS of toggle mapping in NORMAL + VISUAL mode
  ---@type table
  toggler = {
    ---line-comment keymap
    line = 'gcc',
    ---block-comment keymap
    block = 'gbc',
  },

  ---LHS of operator-pending mapping in NORMAL + VISUAL mode
  ---@type table
  opleader = {
    ---line-comment keymap
    line = 'gc',
    ---block-comment keymap
    block = 'gb',
  },

  ---Pre-hook, called before commenting the line
  ---@type function|nil
  pre_hook = function(ctx)
    local U = require('Comment.utils')

    -- Detemine whether to use linewise or blockwise commentstring
    local type = ctx.ctype == U.ctype.line and '__default' or '__multiline'

    -- Determine the location where to calculate commentstring from
    local location = nil
    if ctx.ctype == U.ctype.block then
      location = require('ts_context_commentstring.utils').get_cursor_location()
    elseif ctx.cmotion == U.cmotion.v or ctx.cmotion == U.cmotion.V then
      location = require('ts_context_commentstring.utils').get_visual_start_location()
    end

    return require('ts_context_commentstring.internal').calculate_commentstring({
      key = type,
      location = location,
    })
  end,

  ---Post-hook, called after commenting is done
  ---@type function|nil
  post_hook = nil,
}
EOF

endif

" }}}

" ----------------------------------- 17. Gitsigns {{{

if functions#PluginLoaded('gitsigns.nvim')

lua<<EOF
-- Setup of gitsigns
require("gitsigns").setup {
    signs = {
        add = {
            text = "│",
            hl = "GitSignsAdd",
            numhl = "GitSignsAddNr",
            linehl = "GitSignsAddLn",
        },
        change = {
            text = "│",
            hl = "GitSignsChange",
            numhl = "GitSignsChangeNr",
            linehl = "GitSignsChangeLn",
        },
        delete = {
            text = "-",
            hl = "GitSignsDelete",
            numhl = "GitSignsDeleteNr",
            linehl = "GitSignsDeleteLn",
        },
        topdelete = {
            text = "‾",
            hl = "GitSignsDelete",
            numhl = "GitSignsDeleteNr",
            linehl = "GitSignsDeleteLn",
        },
        changedelete = {
            text = "~",
            hl = "GitSignsChange",
            numhl = "GitSignsChangeNr",
            linehl = "GitSignsChangeLn",
        },
    },
    signcolumn = true, -- Add signs in the signcolumn
    numhl = true, -- Highlights just the number part of the number column
    linehl = false, -- Highlights the whole line
    word_diff = false, -- Highlights just the part of the line that has changed
    watch_gitdir = {
        interval = 1000,
        follow_files = true,
    },
    attach_to_untracked = true,
    current_line_blame = false,
    current_line_blame_opts = {
        virt_text = true,
        virt_text_pos = "eol", -- 'eol' | 'overlay' | 'right_align'
        delay = 1000,
    },
    current_line_blame_formatter_opts = {
        relative_time = false,
    },
    sign_priority = 6,
    update_debounce = 200,
    status_formatter = nil,
    max_file_length = 40000,
    preview_config = { -- Options passed to nvim_open_win
        border = "rounded",
        style = "minimal",
        relative = "cursor",
        row = 0,
        col = 1,
    },
    keymaps = {
        -- Default keymap options
        noremap = true,
        buffer = true,

        -- Move between hunks
        ["n <leader>gj"] = { expr = true, "&diff ? ']c' : '<Cmd>lua require\"gitsigns.actions\".next_hunk()<CR>'" },
        ["n <leader>gk"] = { expr = true, "&diff ? '[c' : '<Cmd>lua require\"gitsigns.actions\".prev_hunk()<CR>'" },

        -- Hunk specific
        ["n <leader>hs"] = "<Cmd>lua require'gitsigns'.stage_hunk()<CR>",
        ["v <leader>hs"] = "<Cmd>lua require'gitsigns'.stage_hunk({vim.fn.line('.'), vim.fn.line('v')})<CR>",
        ["n <leader>hu"] = "<Cmd>lua require'gitsigns'.undo_stage_hunk()<CR>",
        ["n <leader>hr"] = "<Cmd>lua require'gitsigns'.reset_hunk()<CR>",
        ["v <leader>hr"] = "<Cmd>lua require'gitsigns'.reset_hunk({vim.fn.line('.'), vim.fn.line('v')})<CR>",
        ["n <leader>hp"] = "<Cmd>lua require'gitsigns'.preview_hunk()<CR>",
        ["n <leader>hb"] = "<Cmd>lua require'gitsigns'.blame_line{full=true}<CR>",
        ['n <leader>hR'] = "<cmd>lua require'gitsigns'.reset_buffer()<CR>",
        ["n <leader>hS"] = "<Cmd>lua require'gitsigns'.stage_buffer()<CR>",
        ["n <leader>hU"] = "<Cmd>lua require'gitsigns'.reset_buffer_index()<CR>",

        -- Toggling options
        ["n <leader>gb"] = "<Cmd>Gitsigns toggle_current_line_blame<CR>",
        ["n <leader>gh"] = "<Cmd>Gitsigns toggle_linehl<CR>",
        ["n <leader>gn"] = "<Cmd>Gitsigns toggle_numhl<CR>",
        ["n <leader>gs"] = "<Cmd>Gitsigns toggle_signs<CR>",
        ["n <leader>gw"] = "<Cmd>Gitsigns toggle_word_diff<CR>",

        -- Text objects
        ["o ih"] = ':<C-U>lua require"gitsigns.actions".select_hunk()<CR>',
        ["x ih"] = ':<C-U>lua require"gitsigns.actions".select_hunk()<CR>',
    },
}
EOF

endif

" }}}

" }}}

" }}}

