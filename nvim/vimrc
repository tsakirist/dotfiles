" ----------------------------------------- vim: set sw=2: -----------------------------------------
"
"                                 ██╗   ██╗██╗███╗   ███╗██████╗  ██████╗
"                                 ██║   ██║██║████╗ ████║██╔══██╗██╔════╝
"                                 ██║   ██║██║██╔████╔██║██████╔╝██║
"                                 ╚██╗ ██╔╝██║██║╚██╔╝██║██╔══██╗██║
"                                  ╚████╔╝ ██║██║ ╚═╝ ██║██║  ██║╚██████╗
"                                   ╚═══╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝
" Author: Tryfon Tsakiris
"  Email: tr.tsakiris@gmail.com
"    URL: https://raw.githubusercontent.com/tsakirist/dotfiles/master/nvim/vimrc
" --------------------------------------------------------------------------------------------------

" ----------------------------------- 1. Compatible {{{

" Vim defaults to `compatible` when selecting a vimrc with the command-line '-u' argument.
" Override that behaviour to nocompatible.
if &compatible
  set nocompatible
endif

" }}}

" ----------------------------------- 2. Plugins {{{

" ----------------------------------- 1. Plugin installer {{{

" Automate the process of installing vim-plug when required
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
     \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" }}}

" ----------------------------------- 2. Plugin list {{{

" Plugins will be downloaded under the specified directory
call plug#begin('~/.vim/plugged')

" Colorschemes
Plug 'joshdick/onedark.vim'
Plug 'doums/darcula'
Plug 'ghifarit53/tokyonight-vim'

" Lightline statusline and tabline
Plug 'itchyny/lightline.vim', { 'on': [] }
Plug 'mengelbrecht/lightline-bufferline', { 'on': [] }

" Airline statusline/tabline
Plug 'vim-airline/vim-airline', { 'on': [] }
Plug 'vim-airline/vim-airline-themes', { 'on': [] }

" Lua-based statusline
Plug 'hoob3rt/lualine.nvim'

" A temporary tabline for buffers, untill I find a better one
Plug 'pacha/vem-tabline'

" Some useful keymappings
Plug 'tpope/vim-unimpaired'

" Supecharged substitute command and more
Plug 'tpope/vim-abolish'

" Comment lines easily
Plug 'scrooloose/nerdcommenter'

" Multiple cursors like in Sublime3
Plug 'terryma/vim-multiple-cursors'

" Fancy starting screen
Plug 'mhinz/vim-startify'

" Display indentation levels with lines
Plug 'lukas-reineke/indent-blankline.nvim', { 'branch': 'lua' }

" Distraction free mode
Plug 'junegunn/goyo.vim'

" Surround mappings for enclosed text
Plug 'tpope/vim-surround'

" Auto insert brackets, parentheses, etc
Plug 'windwp/nvim-autopairs'

" Easily locate cursor after search
Plug 'inside/vim-search-pulse'

" Show an indication in the sign column for git diffs
Plug 'mhinz/vim-signify'

" A git wrapper for vim
Plug 'tpope/vim-fugitive'

" Enables :GBrowse to open GitHub urls from vim
Plug 'tpope/vim-rhubarb'

" Git blamer with inline text
Plug 'APZelos/blamer.nvim'

" Vim wrapper for UNIX shell commands
" :SudoWrite, :SudoRead doesn't work with nvim
Plug 'tpope/vim-eunuch'

" Write/Read files with sudo from within vim
Plug 'lambdalisue/suda.vim'

" An interactive calculator inside a buffer
Plug 'fedorenchik/VimCalc3'

" Highlight/Underline word under cursor
Plug 'dominikduda/vim_current_word'

" Text alignment
Plug 'junegunn/vim-easy-align'

" Use terminal in a floating pop up window
Plug 'voldikss/vim-floaterm'

" Add file type icons to various plugins
Plug 'kyazdani42/nvim-web-devicons'

" Measure the startup time of vim
Plug 'dstein64/vim-startuptime'

" Display available keybinds in pop-up
Plug 'liuchengxu/vim-which-key'

" Alternate between header/source
Plug 'ton/vim-alternate'

" Rooter changes the working directory to the project root when you open a file or directory
Plug 'airblade/vim-rooter'

" Alternate between absolute/relative numbers
Plug 'jeffkreeftmeijer/vim-numbertoggle'

" Easy resize windows/splits
Plug 'sedm0784/vim-resize-mode'

" Close buffers without losing splits/windows
Plug 'moll/vim-bbye'

" More pleasant commit experience
Plug 'rhysd/committia.vim'

" Git floating popup with blame-commit details
Plug 'rhysd/git-messenger.vim'

" Color highlighter
Plug 'norcalli/nvim-colorizer.lua'

" Visual indication when jumping long distances
Plug 'edluffy/specs.nvim'

" Remove all buffers except current
Plug 'numtostr/BufOnly.nvim', { 'on': 'BufOnly' }

" Highlight first occurences of characters in words, e.g. to move with f{char}
Plug 'unblevable/quick-scope'

" Git diff view
Plug 'sindrets/diffview.nvim'

" Treesitter incremental parsing library
Plug 'nvim-treesitter/nvim-treesitter', { 'do': ':TSUpdate' }
Plug 'nvim-treesitter/nvim-treesitter-textobjects'
Plug 'nvim-treesitter/playground'

" Telescope fuzzy finder
Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'nvim-telescope/telescope-fzy-native.nvim'

" The world-renowned fuzzy finder FZF
" This will try to install FZF outside of vim plug directory
Plug 'junegunn/fzf', { 'dir': '~/.fzf','do': './install --key-bindings --completion --no-update-rc' }
Plug 'junegunn/fzf.vim'

" LSP related
Plug 'neovim/nvim-lspconfig'
Plug 'kabouzeid/nvim-lspinstall'
Plug 'hrsh7th/nvim-compe'
Plug 'ray-x/lsp_signature.nvim'

" Symbols for autocomplete
" Plug 'onsails/lspkind-nvim'

" Cool UI LSP related plugin
" Plug 'glepnir/lspsaga.nvim'

" A visualization plugin for the undo/redo branches
" Plug 'mbbill/undotree'

" Update/auto-generate ctags
" Plug 'ludovicchabant/vim-gutentags'

" -------------------------

" List ends here. Plugins become visible to Vim after this call
call plug#end()

" }}}

" }}}

" ----------------------------------- 3. Settings {{{

" Syntax highlighting
syntax on

" Set true colors inside nvim
set termguicolors

" Custom colorscheme
" silent! colorscheme onedark
" silent! colorscheme darcula
silent! colorscheme tokyonight

" Set the color for the folded sections
highlight Folded guibg=Black guifg=DarkGray

" Highlight the current line and also highlight the column @120 (ruler)
set colorcolumn=120
set cursorline

" Set hidden to on so as to be able to change buffers without saving first
set hidden

" Set hybrid line numbers
set number relativenumber

" Set the number of columns used for line numbers
set numberwidth=1

" Insert spaces when <Tab> is pressed
set expandtab

" Controls the number of space characters inserted when pressing the tab key
set tabstop=4

" Controls the number of space characters inserted for identation
set shiftwidth=4

" Use the indentation level of the previous line when pressing enter
set autoindent

" Do smart auto-indenting when starting a new line
set smartindent

" The two following options are used alongside with linebreak, but I currently use textwidth
" Make wrapped lines to visually indent properly
" set breakindent

" Set the visual character to be shown for wrapped lines
" set showbreak=\ \\_
set showbreak=↪\

" This makes searches case insensitive
set ignorecase

" This makes searches with a single capital letter to be case sensitive
set smartcase

" This highlights the search pattern as you type
set incsearch

" This provides live feedback when substituting
set inccommand=split

" Open new splits/windows always below and right
set splitbelow splitright

" Set automatic wrap to display lines in next line (this is the default)
set wrap

" Set the maximum text width before vim automatically wraps it, this inserts the EOL character
" This is considered a hard-wrap, one can use linebreak to soft-wrap the lines w/o inserting EOL
set textwidth=120

" Set default encoding
set encoding=UTF-8

" Set the fileformat to unix because windows line endings are bad
set fileformat=unix

" This is used to control the Ctrl + C command and copy to the system's clipboard
" set clipboard+=unnamedplus
set clipboard^=unnamed,unnamedplus

" This option will render characters for spaces, tabs etc
" set listchars=trail:·,tab:»·,eol:↲,nbsp:␣,extends:⟩,precedes:⟨
set listchars=nbsp:␣,extends:⟩,precedes:⟨,trail:·,tab:»·
set list

" The number of lines to show above/below when navigating
set scrolloff=5

" This sets the folding method, the default markers are {{{  }}}
set foldmethod=marker

" Set fold enabled
set foldenable

" Foldopen dictates how folds open, jump means it will open with 'gg', 'G'
set foldopen+=jump

" Enable mouse support
set mouse=a

" Enable modeline to allow file secific settings
" e.g. vim: set sw=2:
set modeline

" Make updates happen faster
set updatetime=1000

" Keep windows equal in size after split, close etc
set equalalways

" Set transparency for the popup window
set pumblend=15

" Set completeopt to have a better completion experience
set completeopt=menuone,noinsert,noselect

" Avoid showing message extra message when using completion
set shortmess+=c

" }}}

" ----------------------------------- 4. Autocommands {{{

" Format options configuration:
" 't': is required in format options to wrap text in insert mode
" 'l': a line that is longer than textwidth may not be wraped if 'l' is in format options
" 'r': disables the <CR> key from autocommenting when pressing enter in line that contains a comment
" 'o': don't insert comment when pressing 'o' or 'O'
" 'q': allow formatting comments with gq
autocmd BufEnter * set fo+=t fo-=r fo-=l fo-=o fo+=q

" Remove trailing whitespaces on file save
autocmd BufWritePre * :call functions#TrimTrailingWhitespace()

" This is used to preserve the clipboard when vim exits
autocmd VimLeave * call system("xclip -selection clipboard -i", getreg("+"))

" This will automatically resize windows/splits when resizing host window
autocmd VimResized * wincmd =

if functions#PluginLoaded('vim-eunuch')
  " Remove SudoWrite, SudoEdit from the commands as they do not work
  autocmd VimEnter * :delcommand SudoWrite | :delcommand SudoEdit
endif

" Autocmd configurations for blamer
if functions#PluginLoaded('blamer.nvim')
  " Hide blamer on startup
  autocmd VimEnter * :BlamerHide
endif

" Autocmd configurations for :term
augroup TermAuGroup
  " Clear old autocommands of this group
  autocmd!
  " Automatically enter in insert mode when in terminal pane
  autocmd TermOpen,BufEnter,WinEnter * if &buftype == 'terminal' | :startinsert | endif
  " Disable linenumbering when in terminal
  autocmd TermOpen * setlocal nonumber norelativenumber
augroup END

" }}}

" ----------------------------------- 5. Extra configurations {{{

" Add persistent undo for vim
" ---------------------------
if has('persistent_undo')
  " Define the paths to store the persistent undo files
  let vim_path=expand('$HOME/.vim')
  let undo_path=expand('$HOME/.vim/undo-dir')
  " Create the required directories if needed with the appropriate permissions
  if !isdirectory(vim_path)
    call mkdir(vim_path, "", 0770)
  endif
  if !isdirectory(undo_path)
    call mkdir(undo_path, "", 0700)
  endif
  " Point vim to the defined undo directory and enable undo persistence
  let &undodir=undo_path
  set undofile
endif

" }}}

" ----------------------------------- 6. Keybindings {{{

" Change buffers quickly
nnoremap <silent> <leader>bn :bnext<CR>
nnoremap <silent> <leader>bp :bprevious<CR>
nnoremap <silent> <Tab>      :bnext<CR>
nnoremap <silent> <S-tab>    :bprevious<CR>

" List buffers and prepend :b on the cmd line
nnoremap <leader>bf :ls<CR>:b<Space>

" Close buffer without closing window/split
" nnoremap <silent> <leader>bd :bp<CR>:bd #<CR>

" Use bbye plugin's :Bdelete to close buffer w/o losing splits/windows
nnoremap <silent> <leader>bd :Bdelete<CR>

" Typing %% on the command line will expand to active buffer's path
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Toggle Goyo - distraction free writing
nnoremap <silent> <F1> :Goyo<CR>

" Toggle between folds
nnoremap <expr> <F2> &foldlevel ? 'zM' :'zR'

" Use space to toggle fold
nnoremap <space> za<CR>

" Fill the current line with a leading "<space><prev_line_cols>[-]
nnoremap <expr> <F3> ':call functions#Fill(45)\<CR>'

" Fill the current line with string '" <count><char>'
" nnoremap <expr> <F3> ':call functions#Fill('.getchar().")\<CR>"

" Set Ctrl-t to jump to next occurence of the word under cursor
nnoremap <silent> <C-t> *

" Keybinds to move lines like
" https://vim.fandom.com/wiki/Moving_lines_up_or_down
" gv=gv re-selects the visual block after each operation
" '==' re-indents the line after it has been moved
nnoremap <silent> <C-S-Up> :m-2<CR>==
nnoremap <silent> <C-S-Down> :m+<CR>==
inoremap <silent> <C-S-Up> <Esc>:m-2<CR>==gi
inoremap <silent> <C-S-Down> <Esc>:m+<CR>==gi
vnoremap <silent> <C-S-Up> :m '<-2<CR>gv=gv
vnoremap <silent> <C-S-Down> :m '>+1<CR>gv=gv

nnoremap <silent> <C-K> :m-2<CR>==
nnoremap <silent> <C-J> :m+<CR>==
inoremap <silent> <C-K> <Esc>:m-2<CR>==gi
inoremap <silent> <C-J> <Esc>:m+<CR>==gi
vnoremap <silent> <C-K> :m '<-2<CR>gv=gv
vnoremap <silent> <C-J> :m '>+1<CR>gv=gv

" Duplicate the current line
" 't' command is a synonym for copy
nnoremap <silent> <leader>d :t.<CR>
inoremap <silent> <leader>d <Esc>:t.<CR>
vnoremap <silent> <leader>d :t.<CR>

" Hitting ESC when inside a :term to get into normal mode
tnoremap <Esc> <C-\><C-N>

" Save files with ctrl+s in every mode
nnoremap <C-s> :w<CR>
inoremap <C-s> <Esc>:w<CR>
vnoremap <C-s> <Esc>:w<CR>

" Keymaps to quit current buffer with ctrl+q
nnoremap <silent> <C-q> :q<CR>
inoremap <silent> <C-q> <Esc>:q<CR>
vnoremap <silent> <C-q> <Esc>:q<CR>

" Keymap to quit all buffers with shift+q
nnoremap <silent> <S-q> <Esc>:qa<CR>

" Easiliy toggle comments @NERDCommenter
map <leader><leader> <leader>c<Space>

" Toggling comment in insert mode keeps insert mode :startinsert
imap <leader><leader> <Esc><leader>c<Space>:startinsert<CR>

" Clear highlighting with escape when in normal mode
" https://stackoverflow.com/a/1037182/6654329
nnoremap <silent> <Esc> :noh<return><Esc>
nnoremap <silent> <Esc>^[ <Esc>^[

" Keymap to source the vimrc automatically
nnoremap <silent> <leader>sc :source $MYVIMRC<CR>

" Commands/Keymaps to open terminals horizontally and vertically
command! -nargs=* HT split  | terminal <args>
command! -nargs=* VT vsplit | terminal <args>

nnoremap <silent> <leader>ht :HT<CR>
nnoremap <silent> <leader>vt :VT<CR>

" Keybindings to toggle and kill the floating term window
nnoremap <silent> <leader>ft :FloatermToggle<CR>
nnoremap <silent> <leader>fk :FloatermKill<CR>
tnoremap <silent> <leader>ft <C-\><C-n>:FloatermToggle<CR>
tnoremap <silent> <leader>fk <C-\><C-n>:FloatermKill<CR>

" Make a whole-word search proc with <leader>/
command! -nargs=1 SearchWord call functions#SearchWord(<f-args>)
nnoremap <leader>/ :SearchWord<Space>

" Command and key mapping to enable the zoom-in and zoom-out
command! ZoomToggle call functions#ZoomToggle()
nnoremap <silent> <leader>z :ZoomToggle<CR>

" Change the default mouse scrolling wheel options
nnoremap <ScrollWheelUp>   4<C-y>
nnoremap <ScrollWheelDown> 4<C-e>
xnoremap <ScrollWheelUp>   4<C-y>
xnoremap <ScrollWheelDown> 4<C-e>

" Git-signify keybinds to use the plugin more easily
nnoremap <silent> <leader>gh :SignifyToggleHighlight<CR>
nnoremap <silent> <leader>gf :SignifyFold<CR>
nnoremap <silent> <leader>gd :SignifyDiff<CR>

" Jump between git diff hunks
nmap <silent> <leader>gj <Plug>(signify-next-hunk)
nmap <silent> <leader>gk <Plug>(signify-prev-hunk)
nmap <silent> <leader>gJ 9999<leader>gj
nmap <silent> <leader>gK 9999<leader>gk

" Open git-messenger
nmap <silent> <leader>gm <Plug>(git-messenger)

" EasyAlign keybindings
" 'vipga' starts interactive EasyAlign in visual mode
" 'gaip' starts interactive EasyAlign for text/motion object
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" Use <Tab> and <S-Tab> to navigate through the autocomplete options
inoremap <silent> <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <silent> <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" Remind myself to stop using the god damn arrow keys
nnoremap <silent> <Left>  :echoe "Use h"<CR>
nnoremap <silent> <Right> :echoe "Use l"<CR>
nnoremap <silent> <Up>    :echoe "Use k"<CR>
nnoremap <silent> <Down>  :echoe "Use j"<CR>
vnoremap <silent> <Left>  :<C-u>echoe "Use h"<CR>
vnoremap <silent> <Right> :<C-u>echoe "Use l"<CR>
vnoremap <silent> <Up>    :<C-u>echoe "Use k"<CR>
vnoremap <silent> <Down>  :<C-u>echoe "Use j"<CR>

" Alternate between header/source files
nnoremap <silent> <leader>ko :Alternate<CR>

" Git blame keybind toggle
nnoremap <silent> <leader>gb :BlamerToggle<CR>

" The '&' command repeats last substitution and the
" second '&' keeps the previous flags that were used
" So, usually we want to have this as the default behavior
nnoremap & :&&<CR>
xnoremap & :&&<CR>

" Also, '[q', ']q' work for cprev cnext, check vim-unimpaired
nnoremap <silent> <leader>co :copen<CR>
nnoremap <silent> <leader>cc :cclose<CR>

" Close all buffers except the current one
nnoremap <silent> <leader>bo :BufOnly<CR>

" }}}

" ----------------------------------- 7. Abbreviations {{{

" Shebang abbreviation for bash in scripts
iab #! #!/usr/bin/env bash

" Add multiline C++ comment
iab /** /**<CR><Space>*<CR><Space>*/<Up>

" Add current date
iab idt Date: <C-R>=strftime('%c')<CR>

" Add Lua heredoc
iab lua< lua<<EOF<CR><CR>EOF<Up>

" }}}

" ----------------------------------- 8. Plugins extras {{{

" ----------------------------------- 1. Plugin options {{{

" Set the theme for airline/lightline according to the active colorscheme
if functions#ColorschemeActive('darcula')
  let s:_colorScheme='darculaOriginal'
elseif functions#ColorschemeActive('tokyonight')
  let s:_colorScheme='tokyonight'
else
  let s:_colorScheme='onedark'
endif

" Don't show the mode in airline/lightline
set noshowmode

" Statusline options
" ------------------
if functions#PluginLoaded('vim-airline')

  " Airline options
  " -----------------
  " Specify the default airline theme
  let g:airline_theme=s:_colorScheme

  " Enable tabline extension
  let g:airline#extensions#tabline#enabled=1

  " Add powerline fonts to populate powerline symbols
  let g:airline_powerline_fonts=1

elseif functions#PluginLoaded('lightline.vim')

  " Lightline options
  " -------------------
  " Specify default options
  let g:lightline = {
        \ 'colorscheme': s:_colorScheme,
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ],
        \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ]
        \ },
        \ 'tabline': {
        \   'left': [ ['buffers'] ],
        \   'right': [ ['close'] ]
        \ },
        \ 'component_expand': {
        \   'buffers': 'lightline#bufferline#buffers'
        \ },
        \ 'component_type': {
        \   'buffers': 'tabsel'
        \ },
        \ 'component_function': {
        \   'gitbranch': 'FugitiveHead'
        \ },
        \ 'component_raw': {
        \   'buffers': 1
        \ },
        \}

  " Lightline-bufferline options
  " ------------------------------
  " Add devicons to the bufferline
  let g:lightline#bufferline#enable_devicons=1

  " Make buffer clickable this also requires 'component_raw': 'buffres' : 1
  let g:lightline#bufferline#clickable=1

  " Use different symbols in the buffers for modified etc
  let g:lightline#bufferline#unicode_symbols=1

  " Enable numbering on the buffers, option: 1 as shown by the :ls command
  let g:lightline#bufferline#show_number=1

  " Position the icon to the right of the buffer name
  let g:lightline#bufferline#icon_position="right"

  " This is required for lightline to show the buffers
  set showtabline=2
endif

" Committia options
" -----------------
" Committia plugin minimum width before falling back to single-col layout
let g:committia_min_window_width=140

" Goyo options
" ------------
let g:goyo_width="80%"
let g:goyo_height="85%"
let g:goyo_linenr=0

" Vim-Signify options
" -------------------
" Show text in the sign-column '!' '-' '+'
let g:signify_sign_show_text=1

" Change the delete sign of git-signify from '_' to '-'
let g:signify_sign_delete='-'

" Darcula vim options
" -------------------
" Better highlights for diff
if functions#ColorschemeActive('darcula')
  hi DiffAdded   guifg=#499C54
  hi DiffRemoved guifg=#ab4b52

  " Change the delete color to a shade of red both for sign and line
  hi SignifyLineDelete guibg=#ab4b52
  hi SignifySignDelete guibg=#ab4b5
endif

" Vim Current Word options
" ------------------------
" Do not highlight the word under cursor
let g:vim_current_word#highlight_current_word=0

" Highlight only focused window
let g:vim_current_word#highlight_only_in_focused_window=1

" Suda options
" ------------
" Automatically open files with sudo when needed
let g:suda_smart_edit=1

" Nerd Commenter options
" ----------------------
" Create default mappings
let g:NERDCreateDefaultMappings=1

" Add spaces after comment delimiters by default
let g:NERDSpaceDelims=1

" Do not comment out empty lines
let g:NERDCommentEmptyLines=0

" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace=1

" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign='left'

" Git blamer optionss
" -------------------
let g:blamer_enabled=1
let g:blamer_delay=500

" Startify options
" ----------------
" Specify where to store sessions
let g:startify_session_dir='~/.vim/sessions'

" Automatically update sessions
let g:startify_session_persistence=1

" Use unicode for startify
let g:startify_fortune_use_unicode=1

" Center the header
let g:startify_custom_header='startify#center(startify#fortune#cowsay())'

" Add custom bookmarks
let g:startify_bookmarks=[ {'v': '~/.vimrc'}, {'c': '~/.zshrc'}, {'a': '~/.zsh_aliases'} ]

" Indent-blankline options
" ------------------------
" Set char for each indentation level
" let g:indent_blankline_char_list=['|', '¦', '┆', '┊']

" Contiguous vertical line for indentation
let g:indent_blankline_char_list=['│']

" Do not display indentation on the first column
let g:indent_blankline_show_first_indent_level=v:false

" If there is a single tab in a line, use only tabs to calclulate indentation
let g:indent_blankline_strict_tabs=v:true

" Do not display trailing indentation guide on blank line
let g:indent_blankline_show_trailing_blankline_indent=v:false

" Do not show indentation on blank lines
let g:indent_blankline_show_trailing_blankline_indent=v:false

" Exclude indentation for these filetypes
let g:indent_blankline_filetype_exclude=['help', 'startify']

" Exclude indentation for these buftypes
let g:indent_blankline_buftype_exclude=['terminal']

" Use treesitter to calculate indentation
let g:indent_blankline_use_treesitter=v:true

" Use treesitter to determine current context, and show indent in different highlight
let g:indent_blankline_show_current_context=v:true

" Patterns to match against treesitter nodes for highlighting
let g:indent_blankline_context_patterns=
      \ ['class', 'function', 'method', 'if', 'while', 'for', 'try', 'except', 'argument_list']

" Set the highlight for the treesitter context
highlight IndentBlanklineContextChar guifg=#545c82 gui=nocombine

" Git-messenger options
" ---------------------
" Do not allow plugin defined mappings
let g:git_messenger_no_default_mappings=v:true

" Insert cursor inside pop-up window
let g:git_messenger_always_into_popup=v:true

" Added shadow to the pop-up window
let g:git_messenger_floating_win_opts={'border': 'shadow'}

" Quick-scope options
" -------------------
" Only highlight when pressing these keys
let g:qs_highlight_on_keys=['f', 'F', 't', 'T']

" Vim-rooter options
" ------------------
" Start Rooter manually instead of automatically
let g:rooter_manual_only=1

" Vem-tabline options
" -------------------
" Always show the tabline
let g:vem_tabline_show=2

" Use multiwindow mode for tabline
let g:vem_tabline_multiwindow_mode=v:true

" Show numbers on the buffer tab
let g:vem_tabline_show_number="buffnr"

let g:vem_tabline_number_symbol="| "

" }}}

" ----------------------------------- 2. Plugin configurations {{{

" ----------------------------------- 0. Simple lua plugins {{{

lua << EOF
-- Setup nvim-colorizer
require'colorizer'.setup {}

-- Setup specs-nvim
require('specs').setup {
  show_jumps = true,
  min_jump = 30,
  popup = {
      inc_ms = 8,
      delay_ms = 0,
      blend = 5,
      width = 35,
      winhl = "PMenu",
      fader = require('specs').exp_fader,
      resizer = require('specs').shrink_resizer
  },
  ignore_buftypes = {
    nofile = true,
  },
}
EOF

" Load a custom lualine theme
" https://gist.githubusercontent.com/shadmansaleh/cd526bc166237a5cbd51429cc1f6291b/raw/8702542d9dc40f3323a25480ba35d0082fd4deba/evil_lualine.lua
luafile ~/.vim/plugged/lualine.nvim/lua/lualine/themes/evil_lualine.lua

"}}}

" ----------------------------------- 1. Which-key {{{

if functions#PluginLoaded("vim-which-key")

  " Set the timeout, 1000 is the default
  set timeoutlen=1000

  " Map leader-space to which_key
  nnoremap <silent> <leader><space> :silent <c-u> :silent WhichKey '<Space>'<CR>
  vnoremap <silent> <leader><space> :silent <c-u> :silent WhichKeyVisual '<Space>'<CR>

  " Create map to add keys to
  let g:which_key_map={}

  " Define a separator
  let g:which_key_sep='→'

  " Not a fan of floating windows for this
  let g:which_key_use_floating_win=0

  " Change the colors if you want
  highlight default link WhichKey          Operator
  highlight default link WhichKeySeperator DiffAdded
  highlight default link WhichKeyGroup     Identifier
  highlight default link WhichKeyDesc      Function

  " Hide status line
  autocmd! FileType which_key
  autocmd  FileType which_key set laststatus=0 noshowmode noruler
    \| autocmd BufLeave <buffer> set laststatus=2 noshowmode ruler

  " Single mappings
  let g:which_key_map['/'] = [ '<Plug>NERDCommenterToggle' , 'comment' ]
  let g:which_key_map['e'] = [ ':Vexplore'                 , 'explorer' ]
  let g:which_key_map['f'] = [ ':Files'                    , 'search files' ]
  let g:which_key_map['h'] = [ '<C-w>s'                    , 'split below']
  let g:which_key_map['r'] = [ '<C-w>r'                    , 'rotate split' ]
  let g:which_key_map['R'] = [ ':Rg'                       , 'search text' ]
  let g:which_key_map['S'] = [ ':Startify'                 , 'start screen' ]
  let g:which_key_map['v'] = [ '<C-w>v'                    , 'split right']
  let g:which_key_map['z'] = [ ':Goyo'                     , 'zen' ]

  " s is for search
  let g:which_key_map.s = {
        \ 'name' : '+search' ,
        \ '/' : [':History/'   , 'history'],
        \ ':' : [':Commands'   , 'commands'],
        \ 'a' : [':Ag'         , 'text Ag'],
        \ 'b' : [':BLines'     , 'current buffer'],
        \ 'B' : [':Buffers'    , 'open buffers'],
        \ 'c' : [':Commits'    , 'commits'],
        \ 'C' : [':BCommits'   , 'buffer commits'],
        \ 'f' : [':Files'      , 'files'],
        \ 'g' : [':GFiles'     , 'git files'],
        \ 'G' : [':GFiles?'    , 'modified git files'],
        \ 'h' : [':History'    , 'file history'],
        \ 'H' : [':History:'   , 'command history'],
        \ 'l' : [':Lines'      , 'lines'],
        \ 'L' : [':Ls'         , 'ls'],
        \ 'm' : [':Marks'      , 'marks'],
        \ 'M' : [':Maps'       , 'normal maps'],
        \ 'p' : [':Helptags'   , 'help tags'],
        \ 'P' : [':Tags'       , 'project tags'],
        \ 's' : [':Snippets'   , 'snippets'],
        \ 'S' : [':Colors'     , 'color schemes'],
        \ 't' : [':Rg'         , 'text Ripgrep'],
        \ 'T' : [':BTags'      , 'buffer tags'],
        \ 'w' : [':Windows'    , 'search windows'],
        \ 'y' : [':Filetypes'  , 'file types'],
        \ 'z' : [':FZF'        , 'FZF'],
        \ }

  " b is for buffer
  let g:which_key_map.b = {
        \ 'name' : '+buffer' ,
        \ 'a' : [':ball'       , 'one window per buffer'],
        \ 'd' : [':bd'         , 'delete-buffer'],
        \ 'f' : [':bfirst'     , 'first-buffer'],
        \ 'h' : [':Startify'   , 'home-buffer'],
        \ 'l' : [':blast'      , 'last-buffer'],
        \ 'n' : [':bnext'      , 'next-buffer'],
        \ 'o' : [':BufOnly'    , 'keep current buffer only'],
        \ 'p' : [':bprevious'  , 'previous-buffer'],
        \ '?' : [':Buffers'    , 'fzf-buffers'],
        \ }

  " g is for git
  let g:which_key_map.g = {
        \ 'name' : '+git' ,
        \ 'b' : [':Git blame'   , 'blame'],
        \ 'B' : [':GBrowse'     , 'browse'],
        \ 'd' : [':Git diff'    , 'diff'],
        \ 'l' : [':Git log'     , 'log'],
        \ 'L' : [':Git lg'      , 'lg'],
        \ 's' : [':Gstatus'     , 'status'],
        \ 'S' : [':Git add'     , 'stage'],
        \ 'r' : [':Git reflog'  , 'reflog'],
        \ }

  " p is for vim plug
  let g:which_key_map.p = {
        \ 'name' : '+plug' ,
        \ 'c' : [':PlugClean'   , 'clean'],
        \ 'd' : [':PlugDiff'    , 'diff'],
        \ 'i' : [':PlugInstall' , 'install'],
        \ 's' : [':PlugStatus'  , 'status'],
        \ 'S' : [':PlugSnapshot', 'snapshot'],
        \ 'u' : [':PlugUpdate'  , 'update'],
        \ 'U' : [':PlugUpgrade' , 'upgrade'],
        \ }

  " t is for Telescope
  let g:which_key_map.t = {
        \ 'name' : '+telescope' ,
        \ ':' : [':Telescope commands'                  , 'commands'],
        \ '/' : [':Telescope search_history'            , 'search history'],
        \ 'b' : [':Telescope buffers'                   , 'buffers'],
        \ 'B' : [':Telescope file_browser'              , 'file browser'],
        \ 'c' : [':Telescope current_buffer_fuzzy_find' , 'current buffer lines'],
        \ 'f' : [':Telescope find_files'                , 'find files'],
        \ 'g' : [':Telescope live_grep'                 , 'live grep'],
        \ 'h' : [':Telescope command_history'           , 'command history'],
        \ 'k' : [':Telescope keymaps'                   , 'keymappings'],
        \ 'l' : [':Telescope loclist'                   , 'location list'],
        \ 'm' : [':Telescope marks'                     , 'marks'],
        \ 'M' : [':Telescope man_pages'                 , 'man pages'],
        \ 'o' : [':Telescope oldfiles'                  , 'oldfiles'],
        \ 'O' : [':Telescope vim_options'               , 'vim options'],
        \ 'q' : [':Telscope quickfix'                   , 'quickfix list'],
        \ 's' : [':Telescope grep_string'               , 'search string'],
        \ 't' : [':Telescope tags'                      , 'tags'],
        \}

  " t.g is for Telescope git_*
  let g:which_key_map.t.g = {
        \ 'name' : '+git' ,
        \ 'c' : [':Telescope git_commits'  , 'commmits'],
        \ 'b' : [':Telescope git_bcommits' , 'buffer commmits'],
        \ 'f' : [':Telescope git_files'    , 'git files'],
        \ 'r' : [':Telescope git_branches' , 'git branches'],
        \ 's' : [':Telescope git_status'   , 'git status'],
        \}

  " Register which key map
  call which_key#register('<Space>', "g:which_key_map")

endif

" }}}

" ----------------------------------- 2. FZF {{{

if functions#PluginLoaded('fzf.vim')

  " Custom fzf keybindings for searching
  nnoremap <silent> <leader>fb :Buffers<CR>
  nnoremap <silent> <leader>ff :Files<CR>
  nnoremap <silent> <leader>rg :Rg<CR>
  nnoremap <silent> <leader>fm :Maps<CR>
  nnoremap <silent> <leader>fM :Marks<CR>
  nnoremap <silent> <leader>fh :History:<CR>

  " Start searching for files
  command! -bang -nargs=? -complete=dir Files
    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)

  " Execeute ls on the specified directory
  command! -bang -complete=dir -nargs=? Ls
    \ call fzf#run(fzf#wrap({'source': 'ls', 'dir': <q-args>}, <bang>0))

  " Custom RipgrepFzf function to use with Rg command
  function! RipgrepFzf(query, fullscreen)
    let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
    let initial_command = printf(command_fmt, shellescape(a:query))
    let reload_command = printf(command_fmt, '{q}')
    " Make a centered pop-up window for Rg
    let spec = { 'window': { 'width': 0.9, 'height': 0.7 },
                \'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command] }
    call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
  endfunction

  " Start an interactive Ripgrep search
  command! -nargs=* -bang Rg call RipgrepFzf(<q-args>, <bang>0)

  " Make FZF colors match the active colorscheme
  let g:fzf_colors = {
        \ 'fg':      ['fg', 'Normal'],
        \ 'bg':      ['bg', 'Normal'],
        \ 'hl':      ['fg', 'Comment'],
        \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
        \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
        \ 'hl+':     ['fg', 'Statement'],
        \ 'info':    ['fg', 'PreProc'],
        \ 'border':  ['fg', 'Ignore'],
        \ 'prompt':  ['fg', 'Conditional'],
        \ 'pointer': ['fg', 'Exception'],
        \ 'marker':  ['fg', 'Keyword'],
        \ 'spinner': ['fg', 'Label'],
        \ 'header':  ['fg', 'Comment']
        \}

  " Popup window (anchored to the bottom of the current window)
  " https://github.com/junegunn/fzf/blob/master/README-VIM.md
  let g:fzf_layout = {
        \ 'window':  {
          \ 'width'    : 1.0,
          \ 'height'   : 0.30,
          \ 'relative' : v:true,
          \ 'yoffset'  : 1.0,
          \ 'border'   : 'horizontal',
          \}
        \}

  " This is the default extra key bindings
  let g:fzf_action = {
        \ 'ctrl-t': 'tab split',
        \ 'ctrl-x': 'split',
        \ 'ctrl-v': 'vsplit'
        \}

endif

" }}}

" ----------------------------------- 3. Web-devicons {{{

lua << EOF
function _G.webDevIcons(path)
  local extension = vim.fn.fnamemodify(path, ':e')
  local filename = vim.fn.fnamemodify(path, ':t')
  return require'nvim-web-devicons'.get_icon(filename, extension, { default = true })
end
EOF

function! StartifyEntryFormat() abort
  return 'v:lua.webDevIcons(absolute_path) . " " . entry_path'
endfunction

" Function for vem-tabline, from vim-devicons to web-devicons
function! WebDevIconsGetFileTypeSymbol(path) abort
  return v:lua.webDevIcons(a:path)
endfunction

" }}}

" ----------------------------------- 4. Tree sitter {{{

if functions#PluginLoaded('nvim-treesitter')

lua << EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = {
    'c', 'cpp', 'json', 'python', 'lua', 'bash', 'typescript'
  },

  highlight = {
    enable = true,
  },

  indent = {
    enable = true
  },

  -- This is for nvim-autopairs
  autopairs = {
    enable = true,
  },

  incremental_selection = {
    enable = true,
    keymaps = {
      init_selection = "gnn",
      node_incremental = "grn",
      scope_incremental = "grc",
      node_decremental = "grm",
    }
  },

  textobjects = {
    select = {
      enable = true,
      keymaps = {
        ["af"] = "@function.outer",
        ["if"] = "@function.inner",
        ["al"] = "@loop.outer",
        ["il"] = "@loop.inner",
        ['ac'] = '@conditional.outer',
        ['ic'] = '@conditional.inner',
        ["aC"] = "@class.outer",
        ["iC"] = "@class.inner",
      },
    },

    swap = {
      enable = true,
      swap_next = {
        ["<leader>sp"] = "@parameter.inner",
        ["<leader>sm"] = "@function.outer",
      },
      swap_previous = {
        ["<leader>sP"] = "@parameter.inner",
        ["<leader>sM"] = "@function.outer",
      },
    },

    move = {
      enable = true,
      set_jumps = true,
      goto_next_start = {
        ["]m"] = "@function.outer",
        ["]c"] = "@class.outer",
      },
      goto_next_end = {
        ["]M"] = "@function.outer",
        ["]C"] = "@class.outer",
      },
      goto_previous_start = {
        ["[m"] = "@function.outer",
        ["[c"] = "@class.outer",
      },
      goto_previous_end = {
        ["[M"] = "@function.outer",
        ["[C"] = "@class.outer",
      },
    },

    lsp_interop = {
      enable = true,
      peek_definition_code = {
        ["gf"] = "@function.outer",
        ["gc"] = "@class.outer",
      },
    },

    playground = {
      enable = true,
      updatetime = 25,
      persist_queries = false,
      keybindings = {
        toggle_query_editor = 'o',
        toggle_hl_groups = 'i',
        toggle_injected_languages = 't',
        toggle_anonymous_nodes = 'a',
        toggle_language_display = 'I',
        focus_language = 'f',
        unfocus_language = 'F',
        update = 'R',
        goto_node = '<cr>',
        show_help = '?',
      },
    },
  },
}
EOF

endif

" }}}

" ----------------------------------- 5. Telescope {{{

if functions#PluginLoaded('telescope.nvim')

  " Find files using Telescope command-line sugar
  nnoremap <silent> <leader>fc :Telescope git_commits<CR>
  nnoremap <silent> <leader>fC :Telescope git_bcommits<CR>
  nnoremap <silent> <leader>fh :Telescope command_history<CR>
  nnoremap <silent> <leader>fm :Telescope keymaps<CR>
  nnoremap <silent> <leader>fM :Telescope marks<CR>
  nnoremap <silent> <leader>fo :Telescope oldfiles<CR>
  nnoremap <silent> <leader>fO :Telescope vim_options<CR>
  nnoremap <silent> <leader>fs :Telescope grep_string<CR>
  nnoremap <silent> <leader>fT :Telescope tags<CR>
  nnoremap <silent> <leader>fS :Telescope git_status<CR>

  " Custom commands with extra options
  nnoremap <silent> <leader>fb :lua require'telescope.builtin'.buffers({shorten_path = true})<CR>
  nnoremap <silent> <leader>fB :lua custom_file_browser()<CR>
  nnoremap <silent> <leader>ff :lua require'telescope.builtin'.find_files({shorten_path = true})<CR>
  nnoremap <silent> <leader>fF :lua require'telescope.builtin'.git_files({shorten_path = true})<CR>
  nnoremap <silent> <leader>fg :lua require'telescope.builtin'.live_grep({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fl :lua require'telescope.builtin'.current_buffer_fuzzy_find({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fm :lua require'telescope.builtin'.keymaps(require'telescope.themes'.get_dropdown({}))<CR>
  nnoremap <silent> <leader>fv :lua find_in_vim_root()<CR>
  nnoremap <silent> <leader>fp :lua find_in_project_root()<CR>

  " Make matching characters to follow darcula scheme if active
  if functions#ColorschemeActive('darcula')
    highlight TelescopeMatching guifg=#CC7832
  endif

lua << EOF
local actions = require('telescope.actions')
local action_state = require('telescope.actions.state')

-- Setup Telescope
require'telescope'.setup {
  defaults = {
    prompt_prefix = '❯ ',
    selection_caret = '❯ ',
    winblend = 10,
    preview_cutoff = 120,

    layout_strategy = 'horizontal',
    layout_defaults = {
      horizontal = {
        width_padding = 0.1,
        height_padding = 0.1,
        preview_width = 0.5,
      },
      vertical = {
        width_padding = 0.1,
        height_padding = 0.1,
        preview_height = 0.65,
      }
    },

    selection_strategy = "reset",
    sorting_strategy = "ascending",
    scroll_strategy = "cycle",
    prompt_position = "top",
    color_devicons = true,
    use_less = true,
    set_env = { ['COLORTERM'] = 'truecolor' },
    borderchars = { '─', '│', '─', '│', '╭', '╮', '╯', '╰'},

    file_sorter = require'telescope.sorters'.get_fzy_sorter,
    file_previewer = require'telescope.previewers'.vim_buffer_cat.new,
    grep_previewer = require'telescope.previewers'.vim_buffer_vimgrep.new,
    qflist_previewer = require'telescope.previewers'.vim_buffer_qflist.new,

    mappings = {
      i = {
        ["<C-j>"] = actions.move_selection_next,
        ["<C-k>"] = actions.move_selection_previous,
        ["<C-q>"] = actions.close,
        ["<ESC>"] = actions.close,
        ["<CR>"]  = actions.select_default + actions.center,
        ["<Tab>"] = actions.toggle_selection,
        ["<leader>q"] = actions.smart_send_to_qflist + actions.open_qflist,
      },
      n = {
        ["<C-j>"] = actions.move_selection_next,
        ["<C-k>"] = actions.move_selection_previous,
        ["<leader>q"] = actions.smart_send_to_qflist + actions.open_qflist,
      }
    }
  },

  extensions = {
    fzy_native = {
      override_generic_sorter = true,
      override_file_sorter = true,
    }
  }
}

-- Load extensions
require'telescope'.load_extension('fzy_native')

-- Custom lua function to edit ~/.vim
function find_in_vim_root()
  require'telescope.builtin'.find_files {
    prompt_title = "~/.vim",
    shorten_path = false,
    cwd = "~/.vim",
    follow = true, -- follow symbolic links
    file_ignore_patterns = { "undo%-dir" }, -- character '-' needs escape
    layout_strategy = 'flex',
    layout_config = {
      horizontal = {
        preview_width = 120,
      },
      vertical = {
        preview_height = 0.75,
      }
    }
  }
end

-- Custom lua function to search from project root
-- uses vim-rooter's findRootDirectory function
function find_in_project_root()
  require'telescope.builtin'.find_files {
    prompt_title = "Project root",
    shorten_path = true,
    cwd = vim.fn.FindRootDirectory(),
  }
end

-- Custom file browser with keybindgs
-- '-' go to parent directory
-- '~' go to home directory
function custom_file_browser()
  local opts
  opts = {
    sorting_strategy = "ascending",
    scroll_strategy = "cycle",
    prompt_position = "top",
    attach_mappings = function(prompt_bufnr, map)
      local current_picker = action_state.get_current_picker(prompt_bufnr)
      local modify_cwd = function(new_cwd)
        current_picker.cwd = new_cwd
        current_picker:refresh(opts.new_finder(new_cwd), { reset_prompt = true })
      end
      map('i', '-', function() modify_cwd(current_picker.cwd .. "/..") end)
      map('i', '~', function() modify_cwd(vim.fn.expand("~")) end)
      return true
    end
  }
  require('telescope.builtin').file_browser(opts)
end
EOF

endif

" }}}

" ----------------------------------- 6. Nvim-autopairs {{{

lua << EOF
-- Setup auto-pairs nvim
require'nvim-autopairs'.setup {
  disable_filetype = {
    "TelescopePrompt",
    "vim",
  },
  check_ts = true,
}

-- Fix <CR> for nvim-compe
local nvim_pairs = require('nvim-autopairs')
_G.MUtils = {}
vim.g.completion_confirm_key = ""
MUtils.completion_confirm = function()
  if vim.fn.pumvisible() ~= 0  then
    if vim.fn.complete_info()["selected"] ~= -1 then
      return vim.fn["compe#confirm"](nvim_pairs.esc("<cr>"))
    else
      return nvim_pairs.esc("<cr>")
    end
  else
    return nvim_pairs.autopairs_cr()
  end
end

vim.api.nvim_set_keymap('i', '<CR>', 'v:lua.MUtils.completion_confirm()', {expr = true, noremap = true})
EOF

" }}}

" ----------------------------------- 7. Nvim-compe {{{

lua << EOF
-- Setup nvim-compe
require'compe'.setup {
  enabled = true,
  autocomplete = true,
  debug = false,
  min_length = 1,
  preselect = 'enable',
  throttle_time = 80,
  source_timeout = 200,
  incomplete_delay = 400,
  max_abbr_width = 100,
  max_kind_width = 100,
  max_menu_width = 100,
  documentation = true,
  source = {
    path     = {kind = "   (Path)"},
    buffer   = {kind = "   (Buffer)"},
    calc     = {kind = "   (Calc)"},
    spell    = {kind = "   (Spell)"},
    nvim_lsp = {kind = "   (LSP)"},
    nvim_lua = {kind = "   (Lua)"},
    tags     = {kind = "   (Tag)"},
    vsnip    = false,
  },
}
EOF

" }}}

" ----------------------------------- 8. LSP {{{

lua << EOF
-- Setup LSP configuration
local on_attach = function(client, bufnr)
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings
  local opts = { noremap=true, silent=true }
  buf_set_keymap('n', 'gD'         , '<cmd>lua vim.lsp.buf.declaration()<CR>'                  , opts)
  buf_set_keymap('n', 'gd'         , '<cmd>lua vim.lsp.buf.definition()<CR>'                   , opts)
  buf_set_keymap('n', 'gr'         , '<cmd>lua vim.lsp.buf.references()<CR>'                   , opts)
  buf_set_keymap('n', 'K'          , '<cmd>lua vim.lsp.buf.hover()<CR>'                        , opts)
  buf_set_keymap('n', '<leader>rn' , '<cmd>lua vim.lsp.buf.rename()<CR>'                       , opts)
  buf_set_keymap('n', '<leader>ca' , '<cmd>lua vim.lsp.buf.code_action()<CR>'                  , opts)
  buf_set_keymap('n', '<leader>e'  , '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>' , opts)
  buf_set_keymap('n', '[d'         , '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>'             , opts)
  buf_set_keymap('n', ']d'         , '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>'             , opts)
  buf_set_keymap('n', 'dp'         , '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>'             , opts)
  buf_set_keymap('n', 'dn'         , '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>'             , opts)
  buf_set_keymap('n', '<leader>l'  , '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>'           , opts)

  -- Set some keybinds conditional on server capabilities
  if client.resolved_capabilities.document_formatting then
    buf_set_keymap("n", "<leader>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
  end
  if client.resolved_capabilities.document_range_formatting then
    buf_set_keymap("v", "<leader>f", "<cmd>lua vim.lsp.buf.range_formatting()<CR>", opts)
  end
end

-- Install and setup the required servers
require'lspinstall'.setup{}
local required_servers = {"cpp", "vim", "lua", "bash", "python", "typescript"}
local installed_servers = require'lspinstall'.installed_servers()
for _, server in pairs(required_servers) do
  if not vim.tbl_contains(installed_servers, server) then
    require'lspinstall'.install_server(server)
  end
end

-- Map local buffer keybindings when the server attaches
local installed_servers = require'lspinstall'.installed_servers()
for _, server in pairs(installed_servers) do
  require'lspconfig'[server].setup{on_attach=on_attach}
end

-- Setup lsp-signature
require'lsp_signature'.on_attach({
  bind = true,
  doc_lines = 10,
  hint_enable = false,
  handler_opts = {
    border = "none"   -- double, single, shadow, none
  },
  decorator = {"`", "`"},
})

-- Custom icons for the auto-completion
vim.lsp.protocol.CompletionItemKind = {
  "   (Text) ",
  "   (Method)",
  "   (Function)",
  "   (Constructor)",
  "   (Field)",
  "[] (Variable)",
  "   (Class)",
  " ﰮ  (Interface)",
  "   (Module)",
  " 襁 (Property)",
  "   (Unit)",
  "   (Value)",
  " 練 (Enum)",
  "   (Keyword)",
  "   (Snippet)",
  "   (Color)",
  "   (File)",
  "   (Reference)",
  "   (Folder)",
  "   (EnumMember)",
  " ﲀ  (Constant)",
  "   (Struct)",
  "   (Event)",
  "   (Operator)",
  "   (TypeParameter)"
}
EOF

" }}}

" }}}

" }}}

